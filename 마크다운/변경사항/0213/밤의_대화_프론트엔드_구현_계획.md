# 밤의 대화 프론트엔드 구현 계획

## 개요
밤의 대화 엔드포인트를 Unity 프론트엔드에 통합하기 위한 구체적인 구현 계획입니다.

## 작업일: 2026-02-13

---

## 1. 구현 목표

### 1.1 주요 목표
- `NightDialogueApiClient` 클래스 생성
- `NightDialogueManager`에 API 통합
- 기존 하드코딩된 대화를 API 응답으로 대체
- 응답 파싱 및 상태 변화 적용 로직 구현
- 에러 처리 및 fallback 로직 구현

### 1.2 기존 코드와의 호환성
- `GameStepApiClient`와 유사한 구조로 구현
- `BackendResponseConverter` 패턴 참고
- `ApiClient` 코디네이터에 통합

---

## 2. 구현 단계

### Phase 1: 데이터 구조 정의

#### 2.1 NightDialogueRequest 클래스 생성
**파일:** `Assets/Scripts/Ryu/Global/API/NightDialogueApiClient.cs`

```csharp
[Serializable]
public class NightDialogueRequest
{
    public int day;
}
```

#### 2.2 NightDialogueResponse 클래스 생성
**파일:** `Assets/Scripts/Ryu/Global/API/NightDialogueApiClient.cs`

```csharp
[Serializable]
public class NightDialogueResponse
{
    [JsonProperty("dialogues")]
    public BackendDialogueLine[] dialogues;
    
    [JsonProperty("humanity_change")]
    public float humanity_change;
    
    [JsonProperty("npc_affection_changes")]
    public Dictionary<string, float> npc_affection_changes;
    
    [JsonProperty("npc_humanity_changes")]
    public Dictionary<string, float> npc_humanity_changes;
    
    [JsonProperty("event_flags")]
    public Dictionary<string, bool> event_flags;
    
    [JsonProperty("ending_trigger")]
    public string ending_trigger;
}

[Serializable]
public class BackendDialogueLine
{
    [JsonProperty("speaker_name")]
    public string speaker_name;
    
    [JsonProperty("dialogue")]
    public string dialogue;
}
```

**참고:** 기존 `DialogueLine` 클래스와의 호환성을 위해 변환 메서드 필요

---

### Phase 2: NightDialogueApiClient 클래스 생성

#### 2.1 클래스 구조
**파일:** `Assets/Scripts/Ryu/Global/API/NightDialogueApiClient.cs`

```csharp
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using UnityEngine;
using UnityEngine.Networking;
using Newtonsoft.Json;

/// <summary>
/// 밤의 대화 API를 처리하는 클래스입니다.
/// </summary>
public class NightDialogueApiClient
{
    private string baseUrl;
    private Func<int> getGameId;
    private float timeoutSeconds;
    private string mockResponse;

    /// <summary>
    /// NightDialogueApiClient 생성자
    /// </summary>
    /// <param name="baseUrl">서버 기본 URL</param>
    /// <param name="getGameId">게임 ID를 가져오는 함수</param>
    /// <param name="timeoutSeconds">타임아웃 시간 (초)</param>
    /// <param name="mockResponse">목업 응답 텍스트</param>
    public NightDialogueApiClient(
        string baseUrl, 
        Func<int> getGameId, 
        float timeoutSeconds, 
        string mockResponse)
    {
        this.baseUrl = baseUrl;
        this.getGameId = getGameId;
        this.timeoutSeconds = timeoutSeconds;
        this.mockResponse = mockResponse;
    }

    /// <summary>
    /// 밤의 대화를 요청하는 코루틴을 반환합니다.
    /// </summary>
    /// <param name="day">현재 날짜 (1~5)</param>
    /// <param name="onSuccess">성공 콜백</param>
    /// <param name="onError">에러 콜백</param>
    public IEnumerator RequestNightDialogueCoroutine(
        int day,
        Action<NightDialogueResponse> onSuccess,
        Action<string> onError)
    {
        // 구현 내용은 Phase 2.2 참고
    }
}
```

#### 2.2 API 요청 로직 구현

```csharp
public IEnumerator RequestNightDialogueCoroutine(
    int day,
    Action<NightDialogueResponse> onSuccess,
    Action<string> onError)
{
    int gameId = getGameId();
    string url = $"{baseUrl}/api/v1/game/{gameId}/night_dialogue";

    NightDialogueRequest requestData = new NightDialogueRequest
    {
        day = day
    };

    // Json.NET 사용 (Dictionary 지원)
    string jsonBody = JsonConvert.SerializeObject(requestData);
    Debug.Log($"[NightDialogueApiClient] POST {url} | Body: {jsonBody}");

    using (UnityWebRequest request = new UnityWebRequest(url, "POST"))
    {
        byte[] bodyRaw = Encoding.UTF8.GetBytes(jsonBody);
        request.uploadHandler = new UploadHandlerRaw(bodyRaw);
        request.downloadHandler = new DownloadHandlerBuffer();
        request.SetRequestHeader("Content-Type", "application/json");
        request.SetRequestHeader("ngrok-skip-browser-warning", "true");
        request.timeout = Mathf.CeilToInt(timeoutSeconds);

        yield return request.SendWebRequest();

        // 에러 처리
        if (request.result == UnityWebRequest.Result.ConnectionError
            || request.result == UnityWebRequest.Result.ProtocolError
            || request.result == UnityWebRequest.Result.DataProcessingError)
        {
            Debug.LogWarning($"[NightDialogueApiClient] 요청 실패: {request.error}");
            onError?.Invoke($"요청 실패: {request.error}");
            yield break;
        }

        string responseText = request.downloadHandler.text;

        try
        {
            // Json.NET을 사용하여 응답 파싱
            NightDialogueResponse response = JsonConvert.DeserializeObject<NightDialogueResponse>(responseText);
            
            // 응답 로깅
            string formattedResponse = JsonConvert.SerializeObject(response, Formatting.Indented);
            Debug.Log($"[NightDialogueApiClient] ========== 밤의 대화 응답 ==========");
            Debug.Log($"[NightDialogueApiClient] {formattedResponse}");
            Debug.Log($"[NightDialogueApiClient] ==================================");
            
            onSuccess?.Invoke(response);
        }
        catch (JsonException e)
        {
            Debug.LogError($"[NightDialogueApiClient] JSON 파싱 에러: {e.Message}");
            Debug.LogError($"[NightDialogueApiClient] JSON 내용: {responseText}");
            onError?.Invoke($"응답 파싱 실패: {e.Message}");
        }
        catch (Exception e)
        {
            Debug.LogError($"[NightDialogueApiClient] 예상치 못한 에러: {e.Message}");
            onError?.Invoke($"처리 실패: {e.Message}");
        }
    }
}
```

---

### Phase 3: NightDialogueManager 통합

#### 3.1 필드 추가

**파일:** `Assets/Scripts/Ryu/Night/NightDialogueManager.cs`

```csharp
[Header("API Settings")]
[SerializeField] private bool useApi = true; // API 사용 여부 (디버그용)
private NightDialogueApiClient apiClient;
private bool isRequestingDialogue = false;
```

#### 3.2 API 클라이언트 초기화

```csharp
private void Start()
{
    SetupUILayout();
    
    // 누적 텍스트 초기화
    accumulatedText = "";
    
    if (dialoguePanel != null)
    {
        dialoguePanel.SetActive(true);
    }

    // API 클라이언트 초기화
    if (useApi && GameStateManager.Instance != null)
    {
        InitializeApiClient();
        RequestNightDialogue();
    }
    else
    {
        // Fallback: 기존 하드코딩된 대화 사용
        InitializeDialogues();
        ShowDialogue(0);
    }
}

private void InitializeApiClient()
{
    // ApiClient에서 baseUrl과 gameId 가져오기
    ApiClient apiClientInstance = FindObjectOfType<ApiClient>();
    if (apiClientInstance != null)
    {
        // ApiClient의 필드를 통해 접근 (리플렉션 또는 public getter 필요)
        // 임시로 GameStateManager나 ApiClient 싱글톤 패턴 사용 고려
        string baseUrl = GetBaseUrl(); // 헬퍼 메서드 필요
        Func<int> getGameId = () => GetGameId(); // 헬퍼 메서드 필요
        
        apiClient = new NightDialogueApiClient(
            baseUrl: baseUrl,
            getGameId: getGameId,
            timeoutSeconds: 30f,
            mockResponse: "밤의 대화를 불러오는 중..."
        );
    }
    else
    {
        Debug.LogError("[NightDialogueManager] ApiClient를 찾을 수 없습니다.");
        useApi = false;
        InitializeDialogues();
        ShowDialogue(0);
    }
}

private string GetBaseUrl()
{
    // ApiClient에서 baseUrl 가져오기
    ApiClient apiClientInstance = FindObjectOfType<ApiClient>();
    if (apiClientInstance != null)
    {
        // 리플렉션 또는 public getter 사용
        // 임시 해결책: ApiClient에 public getter 추가
        return apiClientInstance.GetBaseUrl();
    }
    return "https://d564-115-95-186-2.ngrok-free.app"; // 기본값
}

private int GetGameId()
{
    // ApiClient에서 gameId 가져오기
    ApiClient apiClientInstance = FindObjectOfType<ApiClient>();
    if (apiClientInstance != null)
    {
        return apiClientInstance.GetGameId();
    }
    return 1; // 기본값
}
```

#### 3.3 API 요청 메서드

```csharp
private void RequestNightDialogue()
{
    if (isRequestingDialogue)
    {
        Debug.LogWarning("[NightDialogueManager] 이미 대화 요청 중입니다.");
        return;
    }

    if (apiClient == null)
    {
        Debug.LogError("[NightDialogueManager] API 클라이언트가 초기화되지 않았습니다.");
        InitializeDialogues();
        ShowDialogue(0);
        return;
    }

    int currentDay = GameStateManager.Instance != null 
        ? GameStateManager.Instance.GetCurrentDay() 
        : 1;

    isRequestingDialogue = true;
    
    StartCoroutine(apiClient.RequestNightDialogueCoroutine(
        day: currentDay,
        onSuccess: (response) => {
            isRequestingDialogue = false;
            OnNightDialogueReceived(response);
        },
        onError: (error) => {
            isRequestingDialogue = false;
            Debug.LogError($"[NightDialogueManager] 밤의 대화 요청 실패: {error}");
            OnNightDialogueError(error);
        }
    ));
}

private void OnNightDialogueReceived(NightDialogueResponse response)
{
    // 백엔드 응답을 Unity DialogueLine 배열로 변환
    if (response.dialogues != null && response.dialogues.Length > 0)
    {
        dialogues = ConvertToDialogueLines(response.dialogues);
        currentDialogueIndex = 0;
        
        // 첫 번째 대화 표시
        ShowDialogue(0);
        
        // 상태 변화 적용
        ApplyStateChanges(response);
    }
    else
    {
        Debug.LogWarning("[NightDialogueManager] 대화가 비어있습니다. 기본 대화를 사용합니다.");
        InitializeDialogues();
        ShowDialogue(0);
    }
}

private void OnNightDialogueError(string error)
{
    Debug.LogWarning("[NightDialogueManager] API 요청 실패. 기본 대화를 사용합니다.");
    InitializeDialogues();
    ShowDialogue(0);
}

/// <summary>
/// 백엔드 DialogueLine을 Unity DialogueLine으로 변환합니다.
/// </summary>
private DialogueLine[] ConvertToDialogueLines(BackendDialogueLine[] backendLines)
{
    DialogueLine[] unityLines = new DialogueLine[backendLines.Length];
    for (int i = 0; i < backendLines.Length; i++)
    {
        unityLines[i] = new DialogueLine
        {
            speakerName = backendLines[i].speaker_name,
            dialogue = backendLines[i].dialogue
        };
    }
    return unityLines;
}
```

---

### Phase 4: 상태 변화 적용 로직

#### 4.1 ApplyStateChanges 메서드 구현

```csharp
private void ApplyStateChanges(NightDialogueResponse response)
{
    if (GameStateManager.Instance == null)
    {
        Debug.LogWarning("[NightDialogueManager] GameStateManager.Instance가 없습니다. 상태 변화를 적용할 수 없습니다.");
        return;
    }

    // 1. 인간성 변화 적용
    if (response.humanity_change != 0f)
    {
        GameStateManager.Instance.ModifyHumanity(response.humanity_change);
        Debug.Log($"[NightDialogueManager] 인간성 변화: {response.humanity_change}");
    }

    // 2. NPC 호감도 변화 적용
    if (response.npc_affection_changes != null)
    {
        foreach (var change in response.npc_affection_changes)
        {
            NPCType npcType = ConvertNPCNameToType(change.Key);
            if (npcType != NPCType.NewMother) // NewMother는 호감도 변경 불가 (최종보스)
            {
                GameStateManager.Instance.ModifyAffection(npcType, change.Value);
                Debug.Log($"[NightDialogueManager] NPC 호감도 변화: {change.Key} ({npcType}) = {change.Value}");
            }
        }
    }

    // 3. NPC 인간성 변화 적용
    if (response.npc_humanity_changes != null)
    {
        foreach (var change in response.npc_humanity_changes)
        {
            NPCType npcType = ConvertNPCNameToType(change.Key);
            GameStateManager.Instance.ModifyNPCHumanity(npcType, change.Value);
            Debug.Log($"[NightDialogueManager] NPC 인간성 변화: {change.Key} ({npcType}) = {change.Value}");
        }
    }

    // 4. 이벤트 플래그 적용
    if (response.event_flags != null)
    {
        foreach (var flag in response.event_flags)
        {
            GameStateManager.Instance.SetEventFlag(flag.Key, flag.Value);
            Debug.Log($"[NightDialogueManager] 이벤트 플래그 설정: {flag.Key} = {flag.Value}");
        }
    }

    // 5. 엔딩 트리거 확인
    if (!string.IsNullOrEmpty(response.ending_trigger))
    {
        EndingType endingType = ConvertEndingTriggerToType(response.ending_trigger);
        if (endingType != EndingType.None)
        {
            GameStateManager.Instance.TriggerEnding(endingType);
            Debug.Log($"[NightDialogueManager] 엔딩 트리거: {response.ending_trigger} ({endingType})");
        }
    }
}
```

#### 4.2 헬퍼 메서드 구현

```csharp
/// <summary>
/// 백엔드 NPC 이름을 Unity NPCType으로 변환합니다.
/// </summary>
private NPCType ConvertNPCNameToType(string npcName)
{
    switch (npcName.ToLower())
    {
        case "엘리노어":
        case "새엄마":
        case "stepmother":
        case "new_mother":
        case "엘리노어 (새엄마)":
            return NPCType.NewMother;
        
        case "아더":
        case "새아빠":
        case "new_father":
        case "father":
        case "아더 (새아빠)":
            return NPCType.NewFather;
        
        case "루카스":
        case "동생":
        case "sibling":
        case "brother":
        case "루카스 (동생)":
            return NPCType.Sibling;
        
        case "바론":
        case "강아지":
        case "dog":
        case "baron":
            return NPCType.Dog;
        
        case "마가렛":
        case "할머니":
        case "grandmother":
            return NPCType.Grandmother;
        
        default:
            Debug.LogWarning($"[NightDialogueManager] 알 수 없는 NPC 이름: {npcName}");
            return NPCType.NewMother; // 기본값
    }
}

/// <summary>
/// 백엔드 엔딩 트리거 문자열을 Unity EndingType으로 변환합니다.
/// </summary>
private EndingType ConvertEndingTriggerToType(string endingTrigger)
{
    // EndingType enum과 백엔드 ending_id 매핑
    // 실제 EndingType enum 정의에 따라 수정 필요
    switch (endingTrigger.ToLower())
    {
        case "escape":
        case "escape_ending":
            return EndingType.Escape;
        
        case "assimilation":
        case "assimilation_ending":
            return EndingType.Assimilation;
        
        case "death":
        case "death_ending":
            return EndingType.Death;
        
        default:
            Debug.LogWarning($"[NightDialogueManager] 알 수 없는 엔딩 트리거: {endingTrigger}");
            return EndingType.None;
    }
}
```

---

### Phase 5: OnAllDialoguesComplete 수정

#### 5.1 기존 로직 유지 및 개선

```csharp
private void OnAllDialoguesComplete()
{
    Debug.Log("[NightDialogueManager] 모든 대사 표시 완료. 다음 날로 진행합니다.");

    // 주의: 인간성 변화는 이미 ApplyStateChanges에서 적용됨
    // AdvanceToNextDay()는 추가로 -10.0을 감소시키므로 중복 적용 방지 필요
    
    // GameStateManager를 통해 다음 날 진행
    bool gameOverOccurred = false;
    if (GameStateManager.Instance != null)
    {
        // API 응답에서 이미 humanity_change를 적용했으므로
        // AdvanceToNextDay()의 자동 감소를 방지하거나 조정 필요
        // 또는 API 응답의 humanity_change를 사용하지 않고
        // AdvanceToNextDay()의 기본 감소만 사용
        
        // 옵션 1: API 응답의 humanity_change를 우선 사용
        // (이미 ApplyStateChanges에서 적용됨)
        // AdvanceToNextDay()는 날짜만 진행하고 인간성은 변경하지 않음
        
        // 옵션 2: AdvanceToNextDay()의 기본 감소 사용
        // (API 응답의 humanity_change 무시)
        
        // 임시 해결책: API 응답의 humanity_change를 사용하고
        // AdvanceToNextDay()는 날짜만 진행
        // (DayManager에 날짜만 진행하는 메서드 추가 필요)
        
        gameOverOccurred = GameStateManager.Instance.AdvanceToNextDay();
    }
    else
    {
        Debug.LogWarning("[NightDialogueManager] GameStateManager.Instance를 찾을 수 없습니다.");
    }

    // 게임 오버가 발생했으면 씬 전환을 건너뜀
    if (gameOverOccurred)
    {
        Debug.Log("[NightDialogueManager] 게임 오버가 발생했습니다. 씬 전환을 건너뜁니다.");
        return;
    }

    // Tutorial 씬으로 전환 (페이드 효과)
    if (fadeManager != null)
    {
        fadeManager.LoadSceneWithFade(tutorialSceneName, fadeDuration);
    }
    else
    {
        Debug.LogWarning("[NightDialogueManager] SceneFadeManager가 연결되지 않았습니다. 페이드 없이 씬을 전환합니다.");
        UnityEngine.SceneManagement.SceneManager.LoadScene(tutorialSceneName);
    }
}
```

**주의사항:** 
- API 응답의 `humanity_change`와 `AdvanceToNextDay()`의 자동 감소(-10.0)가 중복될 수 있음
- 해결 방안:
  1. API 응답의 `humanity_change`를 우선 사용하고 `AdvanceToNextDay()`는 날짜만 진행
  2. `AdvanceToNextDay()`에 `skipHumanityDecrease` 파라미터 추가
  3. API 응답의 `humanity_change`를 무시하고 `AdvanceToNextDay()`의 기본 감소만 사용

---

### Phase 6: ApiClient 코디네이터 통합

#### 6.1 ApiClient에 NightDialogueApiClient 추가

**파일:** `Assets/Scripts/Ryu/Global/API/ApiClient.cs`

```csharp
// API 클라이언트 인스턴스
private GameStepApiClient gameStepApiClient;
private ScenarioStartApiClient scenarioStartApiClient;
private NightDialogueApiClient nightDialogueApiClient; // 추가

private void Awake()
{
    // API 클라이언트 초기화
    gameStepApiClient = new GameStepApiClient(baseUrl, () => gameId, timeoutSeconds, MOCK_RESPONSE);
    scenarioStartApiClient = new ScenarioStartApiClient(baseUrl, timeoutSeconds);
    nightDialogueApiClient = new NightDialogueApiClient(baseUrl, () => gameId, timeoutSeconds, MOCK_RESPONSE); // 추가
}

// Getter 메서드 추가
public NightDialogueApiClient GetNightDialogueApiClient()
{
    return nightDialogueApiClient;
}

// BaseUrl과 GameId Getter 추가 (NightDialogueManager에서 사용)
public string GetBaseUrl()
{
    return baseUrl;
}

public int GetGameId()
{
    return gameId;
}
```

#### 6.2 NightDialogueManager에서 ApiClient 사용

```csharp
private void InitializeApiClient()
{
    ApiClient apiClientInstance = FindObjectOfType<ApiClient>();
    if (apiClientInstance != null)
    {
        // ApiClient의 NightDialogueApiClient 인스턴스 사용
        apiClient = apiClientInstance.GetNightDialogueApiClient();
    }
    else
    {
        Debug.LogError("[NightDialogueManager] ApiClient를 찾을 수 없습니다.");
        useApi = false;
        InitializeDialogues();
        ShowDialogue(0);
    }
}
```

---

### Phase 7: 에러 처리 및 Fallback

#### 7.1 Fallback 로직

```csharp
private void InitializeDialogues()
{
    // 기존 하드코딩된 대화 (Fallback용)
    dialogues = new DialogueLine[]
    {
        new DialogueLine
        {
            speakerName = "엘리노어 (새엄마)",
            dialogue = "오늘 우리 아이가 보여준 미소 보셨나요? 드디어 이 집의 향기에 적응한 것 같아 마음이 놓여요. 식탁 예절도 몰라보게 우아해졌더군요."
        },
        // ... 나머지 대화
    };
}

private void OnNightDialogueError(string error)
{
    Debug.LogWarning($"[NightDialogueManager] API 요청 실패: {error}");
    Debug.LogWarning("[NightDialogueManager] 기본 대화를 사용합니다.");
    
    // 기본 대화 초기화
    InitializeDialogues();
    currentDialogueIndex = 0;
    
    // 첫 번째 대화 표시
    ShowDialogue(0);
    
    // 기본 인간성 감소 적용 (API 응답 없을 때)
    if (GameStateManager.Instance != null)
    {
        GameStateManager.Instance.ModifyHumanity(-10f);
    }
}
```

#### 7.2 네트워크 오류 처리

```csharp
// NightDialogueApiClient에서 타임아웃 처리
if (request.result == UnityWebRequest.Result.ConnectionError
    || request.result == UnityWebRequest.Result.ProtocolError
    || request.result == UnityWebRequest.Result.DataProcessingError)
{
    Debug.LogWarning($"[NightDialogueApiClient] 요청 실패: {request.error}");
    
    // 타임아웃인 경우 특별 처리
    if (request.result == UnityWebRequest.Result.ConnectionError)
    {
        Debug.LogWarning("[NightDialogueApiClient] 네트워크 연결 오류. Fallback 모드로 전환합니다.");
    }
    
    onError?.Invoke($"요청 실패: {request.error}");
    yield break;
}
```

---

## 3. 구현 순서

### Step 1: 데이터 구조 정의 (30분)
1. `NightDialogueRequest` 클래스 생성
2. `NightDialogueResponse` 클래스 생성
3. `BackendDialogueLine` 클래스 생성

### Step 2: NightDialogueApiClient 생성 (1시간)
1. 클래스 기본 구조 작성
2. API 요청 로직 구현
3. 에러 처리 로직 구현
4. 로깅 추가

### Step 3: ApiClient 통합 (30분)
1. `ApiClient`에 `NightDialogueApiClient` 추가
2. Getter 메서드 추가
3. 초기화 로직 추가

### Step 4: NightDialogueManager 통합 (2시간)
1. API 클라이언트 초기화 로직 추가
2. API 요청 메서드 추가
3. 응답 처리 로직 추가
4. 상태 변화 적용 로직 추가
5. 헬퍼 메서드 구현

### Step 5: 테스트 및 디버깅 (1시간)
1. API 연결 테스트
2. 응답 파싱 테스트
3. 상태 변화 적용 테스트
4. 에러 케이스 테스트

---

## 4. 주의사항

### 4.1 인간성 감소 중복 방지
- API 응답의 `humanity_change`와 `AdvanceToNextDay()`의 자동 감소가 중복될 수 있음
- 해결 방안: `AdvanceToNextDay()`에 `skipHumanityDecrease` 파라미터 추가 또는 API 응답 우선 사용

### 4.2 NPC 이름 매핑
- 백엔드에서 한글 이름("엘리노어", "아더" 등)을 사용할 수 있음
- `ConvertNPCNameToType` 메서드에서 모든 가능한 이름 형식 지원 필요

### 4.3 엔딩 트리거 처리
- `EndingType` enum과 백엔드 `ending_id` 매핑 확인 필요
- 실제 enum 정의에 따라 `ConvertEndingTriggerToType` 수정 필요

### 4.4 기존 대화 유지
- Fallback을 위해 기존 하드코딩된 대화 유지
- 완전히 제거하기 전에 충분한 테스트 필요

---

## 5. 테스트 체크리스트

### 5.1 API 연결 테스트
- [ ] 정상적인 API 요청 성공
- [ ] 응답 파싱 성공
- [ ] 대화 목록 정상 표시

### 5.2 상태 변화 테스트
- [ ] 인간성 변화 적용 확인
- [ ] NPC 호감도 변화 적용 확인
- [ ] NPC 인간성 변화 적용 확인
- [ ] 이벤트 플래그 설정 확인
- [ ] 엔딩 트리거 확인

### 5.3 에러 처리 테스트
- [ ] 네트워크 오류 시 Fallback 동작 확인
- [ ] 잘못된 응답 형식 시 Fallback 동작 확인
- [ ] 타임아웃 시 Fallback 동작 확인

### 5.4 통합 테스트
- [ ] Night 씬에서 API 대화 정상 표시
- [ ] 대화 완료 후 다음 날 진행 확인
- [ ] 씬 전환 정상 동작 확인

---

## 6. 참고 파일

- `Assets/Scripts/Ryu/Global/API/GameStepApiClient.cs` - 참고용 API 클라이언트
- `Assets/Scripts/Ryu/Global/API/BackendResponseConverter.cs` - 응답 변환 패턴 참고
- `Assets/Scripts/Ryu/Night/NightDialogueManager.cs` - 통합 대상
- `Assets/Scripts/Ryu/Global/API/ApiClient.cs` - 코디네이터
- `Assets/Scripts/Ryu/Global/Managers/GameStateManager.cs` - 상태 관리

---

## 변경 이력

- 2026-02-13: 프론트엔드 구현 계획 초안 작성

