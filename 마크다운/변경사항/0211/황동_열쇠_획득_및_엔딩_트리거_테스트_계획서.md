# 황동 열쇠 획득 및 엔딩 트리거 테스트 계획서

## 개요

본 테스트 계획서는 다음 시나리오를 검증하기 위한 구체적인 테스트 절차를 정의합니다:

1. 주방에서 황동 열쇠를 가지고 오는 테스트
2. 인벤토리에 황동 열쇠를 보유하는지 검증하기
3. 나의 방으로 간 후, 개구멍 오브젝트를 클릭하고, "개구멍으로 탈출한다"라는 명령어를 입력하면
4. 백엔드에서 엔딩 트리거를 보내고, 엔딩 씬으로 전환되는지 테스트

**작성일**: 2025-02-11  
**테스트 대상 버전**: Unity 6000.3.5f2  
**프로젝트**: My project (3)

---

## 테스트 환경

### Unity 프로젝트 정보

- **Unity 버전**: 6000.3.5f2
- **플랫폼**: StandaloneWindows64
- **프로젝트 경로**: `C:/Users/rjs72/My project (3)`

### 관련 씬 정보

| 씬 이름 | 파일 경로 | Build Index | 상태 |
|---------|-----------|-------------|------|
| Kitchen | `Assets/Scenes/Ryu/Kitchen.unity` | 6 | 활성 |
| PlayersRoom | `Assets/Scenes/Ryu/PlayersRoom.unity` | 11 | 활성 |
| Tutorial | `Assets/Scenes/Ryu/Tutorial.unity` | 2 | 활성 |
| GameOver | `Assets/Scenes/Ryu/GameOver.unity` | 3 | 활성 |

### 관련 오브젝트 정보

#### Kitchen 씬의 클릭 가능한 오브젝트

| 오브젝트 이름 | 인스턴스 ID | 컴포넌트 | 위치 |
|--------------|-------------|----------|------|
| Item_BrassKey | -122654 | ClickableObject, BoxCollider2D, HoverGlow | (-7.63, 0.0, 0.06) |
| Item_SleepingPill | -122520 | ClickableObject, BoxCollider2D, HoverGlow | (-0.62, -1.78, 0.13) |
| NPC_NewMother | -122504 | ClickableObject, BoxCollider2D, HoverGlow | (-9.31, -1.83, 0.0) |

#### PlayersRoom 씬의 클릭 가능한 오브젝트

| 오브젝트 이름 | 프리팹 경로 | 컴포넌트 | 상태 |
|--------------|-------------|----------|------|
| Item_Hole | `Assets/Assets/Prefabs/Items/Item_Hole.prefab` | ClickableObject, BoxCollider2D, HoverGlow | **프리팹 생성 완료** |

**✅ 업데이트**: `Item_Hole` 프리팹이 생성되었습니다. PlayersRoom 씬에 이 프리팹을 배치하면 TC-03 테스트를 진행할 수 있습니다.

---

## 사전조건

### 필수 사전조건

1. **백엔드 서버 연결**
   - Unity 콘솔에서 다음 로그가 출력되어야 합니다:
     ```
     [GameStepApiClient] POST https://.../api/v1/game/{gameId}/step | Body: {"chat_input":"...","npc_name":"","item_name":""}
     ```
   - 요청 실패 시 타임아웃으로 목업 응답이 반환되며, 엔딩 트리거가 발생하지 않습니다.

2. **Unity Console 로그 모니터링 준비**
   - 다음 키워드로 필터링하여 로그를 캡처할 수 있어야 합니다:
     - `GameStepApiClient`
     - `ApiResponseHandler`
     - `ItemStateApplier`
     - `InventoryManager`
     - `GameStateApplier`
     - `EndingManager`
     - `SceneFadeManager`

3. **게임 상태 초기화**
   - `GameStateManager`가 정상적으로 초기화되어 있어야 합니다.
   - 인벤토리가 비어있는 상태에서 시작합니다.

### 선택적 사전조건 (백엔드 통신 점검)

Git Bash에서 백엔드 서버 연결을 사전 점검할 수 있습니다:

```bash
# Unity 콘솔에 출력된 baseUrl과 gameId를 확인한 후
curl -i 'https://<ngrok-or-server>/api/v1/game/1/step' \
  -H 'Content-Type: application/json' \
  -H 'ngrok-skip-browser-warning: true' \
  --data '{"chat_input":"ping","npc_name":"","item_name":""}'
```

---

## 테스트 케이스

### TC-01: 주방에서 황동 열쇠 획득 테스트

#### 목적
"황동 열쇠 획득" 입력 → 백엔드 응답이 `inventory_add`에 `brass_key`를 포함 → Unity 인벤토리에 `ItemType.BrassKey`가 반영되는지 확인

#### 사전조건
- Kitchen 씬이 활성화되어 있어야 합니다.
- `Item_BrassKey` 오브젝트가 씬에 존재해야 합니다.

#### 테스트 절차

**Step 1**: Kitchen 씬으로 이동
- Unity Editor에서 `Kitchen` 씬을 로드합니다.
- Play 모드로 진입합니다.

**Step 2**: `Item_BrassKey` 오브젝트 클릭
- 화면에서 `Item_BrassKey` 오브젝트를 마우스로 클릭합니다.
- **검증**: 입력창에 `@Item_BrassKey`가 자동으로 삽입되었는지 확인합니다.
- **예상 로그**: `[ClickableObject] Item_BrassKey 클릭 → @Item_BrassKey 삽입`

**Step 3**: 황동 열쇠 획득 명령 입력
- 입력창에 다음 중 하나를 입력합니다:
  - **A안 (블록 포함)**: `@Item_BrassKey 황동 열쇠를 가져온다`
  - **B안 (자연어만)**: `황동 열쇠를 가져온다`
- Enter 키를 눌러 전송합니다.

#### 기대 결과

##### 네트워크 레벨
- Unity Console에 다음 로그가 출력되어야 합니다:
  ```
  [GameStepApiClient] POST https://.../api/v1/game/{gameId}/step | Body: {"chat_input":"...","npc_name":"","item_name":""}
  ```
- "요청 실패 또는 타임아웃" 메시지가 **없어야** 합니다.

##### 백엔드 응답 파싱
- Unity Console에 다음 로그 블록이 출력되어야 합니다:
  ```
  [GameStepApiClient] ========== 백엔드 원본 응답 ==========
  [GameStepApiClient] {responseText}
  [GameStepApiClient] ======================================
  [GameStepApiClient] ========== 백엔드 응답 (파싱됨) ==========
  [GameStepApiClient] {formattedResponse}
  [GameStepApiClient] ==========================================
  ```

##### 아이템 반영 검증
백엔드 응답의 `state_delta.inventory_add` 배열에 `"brass_key"`가 포함되어야 하며, Unity Console에 다음 로그가 순서대로 출력되어야 합니다:

1. `[ItemStateApplier] 아이템 획득: BrassKey x1`
2. `[InventoryManager] 아이템 추가: BrassKey x1 (총 1개)`

#### 실패 판정 기준

- 백엔드 응답의 `inventory_add`에 `brass_key`가 포함되지 않은 경우
- 위의 인벤토리 관련 로그가 출력되지 않은 경우
- 타임아웃으로 목업 응답이 반환된 경우 (엔딩/아이템 변화 없음)

#### 증빙 자료

- Unity Console 로그 캡처 (특히 `ItemStateApplier`, `InventoryManager` 로그)
- 백엔드 응답 JSON 캡처 (가능한 경우)

---

### TC-02: 인벤토리 보유 상태 검증

#### 목적
"황동 열쇠 보유" 상태가 클라이언트에 유지되는지 확인 (씬 이동 후에도 유지되는지 검증)

#### 사전조건
- TC-01이 성공적으로 완료되어 `BrassKey` 아이템이 인벤토리에 추가된 상태여야 합니다.
- Unity Console에 `[InventoryManager] 아이템 추가: BrassKey x1 (총 1개)` 로그가 한 번 이상 출력되었어야 합니다.

#### 테스트 절차

**Step 1**: 씬 이동
- Kitchen 씬에서 PlayersRoom 씬으로 이동합니다.
  - 개발용 숫자키 이동이 활성화되어 있다면 숫자키 `1`을 눌러 이동합니다.
  - 또는 `SceneFadeManager.LoadSceneWithFade("PlayersRoom", 1f)`를 직접 호출합니다.

**Step 2**: 씬 전환 확인
- 씬 전환 중/후 Unity Console에 에러가 없는지 확인합니다.
- **예상 로그**: `[SceneFadeManager] 페이드 아웃 시작 → PlayersRoom 씬으로 전환`

#### 기대 결과

##### 게임 상태 유지
- `GameStateManager`는 `DontDestroyOnLoad`로 설정되어 있으므로 **인벤토리 상태가 유지**되어야 합니다.
- 씬 전환 후에도 `GameStateManager.Instance.HasItem(ItemType.BrassKey)`가 `true`를 반환해야 합니다.

##### 로그 검증
- 씬 전환 중 Unity Console에 에러가 없어야 합니다.
- (현재 UI 기반 인벤토리 표시가 확실하지 않으므로) 증빙은 **콘솔 로그 중심**으로 남깁니다.


#### 실패 판정 기준

- 씬 전환 중 Unity Console에 에러가 발생한 경우
- `GameStateManager.Instance.HasItem(ItemType.BrassKey)`가 `false`를 반환하는 경우

#### 증빙 자료

- TC-01의 `[InventoryManager] 아이템 추가: BrassKey...` 로그 캡처
- 씬 이동 후 Unity Console 에러 로그 캡처 (에러가 없는 경우 "에러 없음" 명시)

---

### TC-03: 개구멍 오브젝트 클릭 및 탈출 명령 입력

#### 목적
"개구멍 클릭으로 블록 삽입 + 명령 입력" UX/입력 흐름 검증

#### 사전조건
- PlayersRoom 씬이 활성화되어 있어야 합니다.
- `Item_Hole` 프리팹이 PlayersRoom 씬에 배치되어 있어야 합니다.
- **✅ 업데이트**: `Item_Hole` 프리팹이 생성되었습니다 (`Assets/Assets/Prefabs/Items/Item_Hole.prefab`).

#### 테스트 절차

**Step 1**: PlayersRoom 씬으로 이동
- Kitchen 또는 다른 씬에서 PlayersRoom 씬으로 이동합니다.

**Step 2**: 개구멍 오브젝트 배치 확인
- 씬 Hierarchy에서 `Item_Hole` GameObject가 존재하는지 확인합니다.
- 없을 경우, `Assets/Assets/Prefabs/Items/Item_Hole.prefab`을 씬에 드래그 앤 드롭하여 배치합니다.

**Step 3**: 개구멍 오브젝트 클릭
- 화면에서 `Item_Hole` 오브젝트를 마우스로 클릭합니다.
- **검증**: 입력창에 `@Item_Hole`이 자동으로 삽입되었는지 확인합니다.
- **예상 로그**: `[ClickableObject] Item_Hole 클릭 → @Item_Hole 삽입`

**Step 4**: 탈출 명령 입력
- 입력창에 다음을 입력합니다:
  - **A안 (블록 포함)**: `@Item_Hole 개구멍으로 탈출한다`
  - **B안 (자연어만)**: `개구멍으로 탈출한다`
- Enter 키를 눌러 전송합니다.

#### 기대 결과

##### 클릭 이벤트
- `Item_Hole` 오브젝트 클릭 시 Unity Console에 다음 로그가 출력되어야 합니다:
  ```
  [ClickableObject] Item_Hole 클릭 → @Item_Hole 삽입
  ```
- 입력창에 `@Item_Hole`이 자동으로 삽입되어야 합니다.

##### 명령 전송
- 입력 전송 후 Unity Console에 다음 로그가 출력되어야 합니다:
  ```
  [InputHandler] 입력 전송: @Item_Hole 개구멍으로 탈출한다
  [GameStepApiClient] POST https://.../api/v1/game/{gameId}/step | Body: ...
  ```

#### 현재 상태 판정

**✅ 진행 가능**

**근거**:
- `Item_Hole` 프리팹이 생성되었습니다 (`Assets/Assets/Prefabs/Items/Item_Hole.prefab`).
- 프리팹에는 다음 컴포넌트가 포함되어 있습니다:
  - `SpriteRenderer` (개구멍.png 스프라이트)
  - `BoxCollider2D` (클릭 감지용)
  - `HoverGlow` (호버 효과)
  - `ClickableObject` (`blockName: "Item_Hole"`로 설정됨)
- PlayersRoom 씬에 프리팹을 배치하면 테스트를 진행할 수 있습니다.

#### 실패 판정 기준

- 개구멍 오브젝트를 찾을 수 없는 경우
- 클릭해도 입력창에 블록이 삽입되지 않는 경우
- `ClickableObject` 컴포넌트가 없는 경우

#### 증빙 자료

- PlayersRoom 씬 Hierarchy 스크린샷
- Unity Console 로그 캡처 (클릭 이벤트 로그가 없는 경우 "로그 없음" 명시)

---

### TC-04: 백엔드 엔딩 트리거 수신 및 엔딩 씬 전환 검증

#### 목적
백엔드가 `ending_info.ending_type`을 보내면, 클라이언트가 이를 수신/적용하고 씬 전환까지 되는지 확인

#### 사전조건
- TC-01, TC-02가 성공적으로 완료되어 `BrassKey` 아이템이 인벤토리에 보유되어 있어야 합니다.
- 백엔드 서버가 정상적으로 연결되어 있어야 합니다.
- (TC-03이 완료되었다면) "개구멍으로 탈출한다" 명령이 전송된 상태여야 합니다.

#### 테스트 절차

**Step 1**: 엔딩 유발 입력 전송
- "개구멍으로 탈출한다"를 포함하여 엔딩을 유발하는 입력을 전송합니다.
- 백엔드가 엔딩을 반환하도록 시나리오/상태가 맞아야 합니다.
- 예시 입력:
  - `@Item_Hole 개구멍으로 탈출한다`
  - `개구멍으로 탈출한다`
  - `@Item_BrassKey 황동 열쇠를 사용해서 개구멍으로 탈출한다`

**Step 2**: Unity Console 로그 확인
- 다음 로그가 순서대로 출력되는지 확인합니다.

#### 기대 결과

##### 엔딩 트리거 수신 로그 (핵심 검증 포인트)

Unity Console에 다음 로그가 **순서대로** 출력되어야 합니다:

1. **API 응답 수신**
   ```
   [ApiResponseHandler] 응답 수신: <narrative>
   ```

2. **엔딩 트리거 처리**
   ```
   [GameStateApplier] 백엔드에서 엔딩 트리거 수신: <EndingType>
   ```

3. **엔딩 매니저 트리거**
   ```
   [EndingManager] 엔딩 트리거: <EndingType>
   ```

4. **씬 전환 시도**
   ```
   [SceneFadeManager] 페이드 아웃 시작 → Ending_<EndingType> 씬으로 전환
   [SceneFadeManager] Ending_<EndingType> 씬 로드 중...
   ```

##### 엔딩 타입별 예상 씬 이름

`EndingManager.GetEndingSceneName()` 메서드에 따르면:

| EndingType | 예상 씬 이름 |
|------------|-------------|
| StealthExit | `Ending_StealthExit` |
| ChaoticBreakout | `Ending_ChaoticBreakout` |
| SiblingsHelp | `Ending_SiblingsHelp` |
| UnfinishedDoll | `GameOver` |
| EternalDinner | `Ending_EternalDinner` |

#### 현재 프로젝트에서의 예상 문제

**⚠️ 높은 확률로 실패 예상**

**근거**:
- `EndingManager`가 로드하려는 씬: `Ending_StealthExit`, `Ending_ChaoticBreakout`, `Ending_SiblingsHelp`, `Ending_EternalDinner`
- 프로젝트 `Assets/Scenes/Ryu/` 폴더에 해당 씬 파일이 **존재하지 않습니다**.
- Build Settings에도 해당 씬이 **등록되어 있지 않습니다**.

**예상 에러 로그**:
```
[SceneFadeManager] 씬 로드 실패: 'Ending_StealthExit' (Build Profiles/Shared scene list에 씬이 등록되어 있어야 합니다)
[SceneFadeManager] 씬 전환에 실패했습니다: 'Ending_StealthExit'. 검은 화면 복구를 위해 페이드 인합니다.
```

#### Pass/Fail 기준

##### Pass (엔딩 트리거 수신까지)
- Unity Console에 `[GameStateApplier] 백엔드에서 엔딩 트리거 수신: <EndingType>` 로그가 출력됨
- Unity Console에 `[EndingManager] 엔딩 트리거: <EndingType>` 로그가 출력됨

##### Pass (엔딩 씬 전환까지)
- 실제로 `Ending_*` 씬이 로드되어 활성 씬이 변경됨
- Unity Console에 `[SceneFadeManager] 페이드 아웃 시작 → Ending_... 씬으로 전환` 로그가 출력되고 에러가 없음

##### Fail
- 엔딩 트리거는 수신되었으나 씬 로드가 불가한 경우 (현재는 이 케이스가 유력)
- Unity Console에 `[SceneFadeManager] 씬 로드 실패: ...` 에러 로그가 출력됨

#### 실패 판정 기준

- 백엔드 응답에 `ending_info.ending_type`이 포함되지 않은 경우
- `GameStateApplier.ApplyEndingTrigger()`가 `false`를 반환하는 경우
- 씬 로드 실패 에러가 발생한 경우

#### 증빙 자료

- Unity Console 로그 캡처 (특히 `GameStateApplier`, `EndingManager`, `SceneFadeManager` 로그)
- 백엔드 응답 JSON 캡처 (가능한 경우, `ending_info` 필드 포함)
- 씬 전환 실패 시 에러 로그 캡처

---

## 테스트 실행 체크리스트

### 사전 준비

- [ ] Unity Editor에서 프로젝트를 열었습니다.
- [ ] 백엔드 서버가 정상적으로 실행 중입니다.
- [ ] Unity Console 창을 열고 로그 필터를 설정했습니다.
- [ ] Git Bash에서 백엔드 연결을 사전 점검했습니다 (선택).

### TC-01: 황동 열쇠 획득

- [ ] Kitchen 씬을 로드했습니다.
- [ ] Play 모드로 진입했습니다.
- [ ] `Item_BrassKey` 오브젝트를 클릭했습니다.
- [ ] 입력창에 `@Item_BrassKey`가 삽입되었는지 확인했습니다.
- [ ] "황동 열쇠를 가져온다" 명령을 입력하고 전송했습니다.
- [ ] Unity Console에 `[GameStepApiClient] POST ...` 로그가 출력되었는지 확인했습니다.
- [ ] Unity Console에 `[ItemStateApplier] 아이템 획득: BrassKey x1` 로그가 출력되었는지 확인했습니다.
- [ ] Unity Console에 `[InventoryManager] 아이템 추가: BrassKey x1 (총 1개)` 로그가 출력되었는지 확인했습니다.
- [ ] 로그를 캡처했습니다.

### TC-02: 인벤토리 보유 상태 검증

- [ ] TC-01이 성공적으로 완료되었습니다.
- [ ] Kitchen → PlayersRoom 씬으로 이동했습니다.
- [ ] 씬 전환 중 Unity Console에 에러가 없는지 확인했습니다.
- [ ] (선택) 동일한 "황동 열쇠 관련 입력"을 1회 더 전송하여 백엔드가 "이미 보유" 상태를 인식하는지 확인했습니다.
- [ ] 로그를 캡처했습니다.

### TC-03: 개구멍 오브젝트 클릭

- [ ] PlayersRoom 씬을 로드했습니다.
- [ ] `Item_Hole` 프리팹이 씬에 배치되어 있는지 확인했습니다 (없을 경우 프리팹을 배치).
- [ ] `Item_Hole` 오브젝트를 클릭했습니다.
- [ ] 입력창에 `@Item_Hole`이 삽입되었는지 확인했습니다.
- [ ] Unity Console에 `[ClickableObject] Item_Hole 클릭 → @Item_Hole 삽입` 로그가 출력되었는지 확인했습니다.
- [ ] "개구멍으로 탈출한다" 명령을 입력하고 전송했습니다 (A안: `@Item_Hole 개구멍으로 탈출한다`, B안: `개구멍으로 탈출한다`).
- [ ] Unity Console에 `[InputHandler] 입력 전송: ...` 로그가 출력되었는지 확인했습니다.
- [ ] 로그를 캡처했습니다.

### TC-04: 엔딩 트리거 및 씬 전환

- [ ] TC-01, TC-02가 성공적으로 완료되었습니다.
- [ ] "개구멍으로 탈출한다" 명령을 전송했습니다 (또는 엔딩을 유발하는 다른 명령).
- [ ] Unity Console에 `[ApiResponseHandler] 응답 수신: ...` 로그가 출력되었는지 확인했습니다.
- [ ] Unity Console에 `[GameStateApplier] 백엔드에서 엔딩 트리거 수신: <EndingType>` 로그가 출력되었는지 확인했습니다.
- [ ] Unity Console에 `[EndingManager] 엔딩 트리거: <EndingType>` 로그가 출력되었는지 확인했습니다.
- [ ] Unity Console에 `[SceneFadeManager] 페이드 아웃 시작 → Ending_... 씬으로 전환` 로그가 출력되었는지 확인했습니다.
- [ ] (성공 시) 실제로 엔딩 씬이 로드되었는지 확인했습니다.
- [ ] (실패 시) `[SceneFadeManager] 씬 로드 실패: ...` 에러 로그를 확인했습니다.
- [ ] 로그를 캡처했습니다.

---

## 알려진 이슈 및 제약사항

### 1. PlayersRoom 씬에 개구멍 오브젝트 배치 필요

**상태**: ✅ 해결됨 (프리팹 생성 완료)  
**영향**: TC-03 테스트 진행 가능 (프리팹 배치 필요)  
**해결 방안**: `Item_Hole` 프리팹이 생성되었습니다. PlayersRoom 씬에 프리팹을 배치하면 테스트를 진행할 수 있습니다.

**프리팹 정보**:
- **경로**: `Assets/Assets/Prefabs/Items/Item_Hole.prefab`
- **이름**: `Item_Hole`
- **포함 컴포넌트**:
  - `SpriteRenderer` (개구멍.png 스프라이트)
  - `BoxCollider2D` (클릭 감지용)
  - `HoverGlow` (호버 효과, glowMultiplier: 1.5)
  - `ClickableObject` (`blockName: "Item_Hole"`)

**사용 방법**:
- Unity Editor에서 `Assets/Assets/Prefabs/Items/Item_Hole.prefab`을 PlayersRoom 씬에 드래그 앤 드롭하여 배치합니다.
- 클릭 시 입력창에 `@Item_Hole`이 자동으로 삽입됩니다.

### 2. 엔딩 씬 파일이 존재하지 않음

**상태**: 높은 확률로 실패 예상  
**영향**: TC-04의 씬 전환 단계가 실패할 가능성이 높음  
**해결 방안**: 다음 엔딩 씬 파일을 생성하고 Build Settings에 등록해야 합니다:

- `Assets/Scenes/Ryu/Ending_StealthExit.unity`
- `Assets/Scenes/Ryu/Ending_ChaoticBreakout.unity`
- `Assets/Scenes/Ryu/Ending_SiblingsHelp.unity`
- `Assets/Scenes/Ryu/Ending_EternalDinner.unity`

**참고**: `EndingType.UnfinishedDoll`은 `GameOver` 씬을 사용하므로 이미 존재합니다.

### 3. 백엔드 타임아웃 시 목업 응답 반환

**상태**: 정상 동작 (의도된 동작)  
**영향**: 백엔드 서버가 응답하지 않으면 엔딩 트리거가 발생하지 않습니다.  
**해결 방안**: 백엔드 서버가 정상적으로 실행 중인지 확인하고, 타임아웃 시간(기본 3초)을 조정할 수 있습니다.

**설정 위치**: `Assets/Scripts/Ryu/Global/API/ApiClient.cs`
```csharp
[SerializeField] private float timeoutSeconds = 3f;
```

---

## 테스트 결과 기록 템플릿

### TC-01: 황동 열쇠 획득

| 항목 | 결과 |
|------|------|
| **테스트 날짜** | YYYY-MM-DD |
| **테스트 환경** | Unity 6000.3.5f2, Windows |
| **결과** | ✅ PASS / ❌ FAIL / ⚠️ BLOCKED |
| **백엔드 응답** | `inventory_add`에 `brass_key` 포함 여부 |
| **Unity 로그** | `[ItemStateApplier]`, `[InventoryManager]` 로그 출력 여부 |
| **증빙 자료** | 로그 캡처 파일 경로 |
| **비고** | 특이사항, 에러 메시지 등 |

### TC-02: 인벤토리 보유 상태 검증

| 항목 | 결과 |
|------|------|
| **테스트 날짜** | YYYY-MM-DD |
| **테스트 환경** | Unity 6000.3.5f2, Windows |
| **결과** | ✅ PASS / ❌ FAIL / ⚠️ BLOCKED |
| **씬 전환** | 성공 여부 |
| **인벤토리 유지** | `HasItem(ItemType.BrassKey)` 반환값 |
| **증빙 자료** | 로그 캡처 파일 경로 |
| **비고** | 특이사항, 에러 메시지 등 |

### TC-03: 개구멍 오브젝트 클릭

| 항목 | 결과 |
|------|------|
| **테스트 날짜** | YYYY-MM-DD |
| **테스트 환경** | Unity 6000.3.5f2, Windows |
| **결과** | ✅ PASS / ❌ FAIL / ⚠️ BLOCKED |
| **Item_Hole 프리팹 배치** | 예 / 아니오 |
| **클릭 이벤트 로그** | `[ClickableObject] Item_Hole 클릭 → @Item_Hole 삽입` 출력 여부 |
| **입력창 블록 삽입** | `@Item_Hole` 삽입 여부 |
| **증빙 자료** | Hierarchy 스크린샷, 로그 캡처 파일 경로 |
| **비고** | **✅ 프리팹 생성 완료 - 씬에 배치 후 테스트 가능** |

### TC-04: 엔딩 트리거 및 씬 전환

| 항목 | 결과 |
|------|------|
| **테스트 날짜** | YYYY-MM-DD |
| **테스트 환경** | Unity 6000.3.5f2, Windows |
| **결과** | ✅ PASS / ❌ FAIL / ⚠️ BLOCKED |
| **엔딩 트리거 수신** | `[GameStateApplier]` 로그 출력 여부 |
| **엔딩 매니저 트리거** | `[EndingManager]` 로그 출력 여부 |
| **씬 전환 성공** | 예 / 아니오 |
| **씬 전환 실패 원인** | (실패 시) 에러 메시지 |
| **증빙 자료** | 로그 캡처 파일 경로 |
| **비고** | 특이사항, 에러 메시지 등 |

---

## 참고 자료

### 관련 스크립트 파일

- `Assets/Scripts/Ryu/Global/API/GameStepApiClient.cs` - 백엔드 API 통신
- `Assets/Scripts/Ryu/Global/API/ApiResponseHandler.cs` - API 응답 처리
- `Assets/Scripts/Ryu/Global/State/ItemStateApplier.cs` - 아이템 상태 적용
- `Assets/Scripts/Ryu/Global/Managers/InventoryManager.cs` - 인벤토리 관리
- `Assets/Scripts/Ryu/Global/State/GameStateApplier.cs` - 엔딩 트리거 처리
- `Assets/Scripts/Ryu/Global/Managers/EndingManager.cs` - 엔딩 관리
- `Assets/Scripts/Ryu/Global/Utils/SceneFadeManager.cs` - 씬 전환 및 페이드
- `Assets/Scripts/Ryu/Tutorial/ClickableObject.cs` - 클릭 가능한 오브젝트
- `Assets/Scripts/Ryu/Tutorial/InputHandler.cs` - 입력 처리

### 관련 Enum 및 데이터 타입

- `ItemType.BrassKey` - 황동 열쇠 아이템 타입
- `EndingType` - 엔딩 타입 enum (StealthExit, ChaoticBreakout, SiblingsHelp, UnfinishedDoll, EternalDinner)
- `GameLocation` - 게임 위치 enum (Kitchen, PlayersRoom 등)

### 관련 문서

- `마크다운/개발/맵_간_화면_이동_시스템_기획안.md` - 씬 전환 시스템 기획
- `마크다운/변경사항/0211/방_씬_생성_시스템_구축_계획.md` - 씬 생성 시스템 계획

---

## 변경 이력

| 날짜 | 버전 | 변경 내용 | 작성자 |
|------|------|-----------|--------|
| 2025-02-11 | 1.0 | 초안 작성 | AI Assistant |
| 2025-02-11 | 1.1 | Item_Hole 프리팹 생성 완료 - TC-03 상태를 BLOCKED에서 진행 가능으로 업데이트 | AI Assistant |

---

## 부록: 백엔드 응답 예시

### 성공적인 황동 열쇠 획득 응답 예시

```json
{
  "narrative": "당신은 조용히 새엄마의 목걸이에서 황동 열쇠를 빼냈습니다. 아무도 눈치채지 못했습니다.",
  "ending_info": null,
  "state_delta": {
    "humanity_change": 0.0,
    "inventory_add": ["brass_key"],
    "inventory_remove": [],
    "npc_stats": {},
    "flags": {},
    "item_state_changes": []
  }
}
```

### 성공적인 엔딩 트리거 응답 예시

```json
{
  "narrative": "당신은 개구멍으로 몸을 내밀었습니다. 황동 열쇠로 문을 열고 조용히 탈출했습니다.",
  "ending_info": {
    "ending_type": "stealth_exit",
    "description": "완벽한 기만 - 당신은 아무도 눈치채지 못하게 탈출했습니다."
  },
  "state_delta": {
    "humanity_change": 0.0,
    "inventory_add": [],
    "inventory_remove": ["brass_key"],
    "npc_stats": {},
    "flags": {
      "hole_unlocked": true
    },
    "item_state_changes": []
  }
}
```

---

**문서 끝**

