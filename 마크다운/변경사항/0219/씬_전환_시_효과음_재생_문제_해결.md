# 씬 전환 시 효과음 재생 문제 해결 (2026-02-19)

## 문제 상황

### 발견된 문제
- `kitchentodoor` 오브젝트를 클릭했을 때 사운드 이펙트가 들리지 않음
- 콘솔에는 "클릭 효과음 재생" 로그가 출력됨
- 오디오 클립은 정상적으로 할당되어 있음

### 원인 분석

**핵심 문제**: 씬 전환 시 현재 씬의 모든 오브젝트가 파괴되면서 오디오 재생이 중단됨

**실행 흐름**:
1. `OnMouseDown()` 호출
2. `PlayClickSound()` 호출 → `AudioSource.PlayClipAtPoint()` 실행
3. `TransitionToScene()` 호출 → `SceneFadeManager.LoadSceneWithFade()` 실행
4. 페이드 아웃 코루틴 시작 (0.2초)
5. `SceneManager.LoadScene()` 호출 → **현재 씬의 모든 오브젝트 파괴**
6. **오디오가 재생되기 전 또는 재생 중에 씬이 전환되어 오디오가 중단됨**

**기술적 원인**:
- `AudioSource.PlayClipAtPoint()`는 임시 AudioSource를 생성하여 재생
- 이 임시 AudioSource는 현재 씬에 속함
- 씬 전환 시 현재 씬의 모든 오브젝트가 파괴되므로 오디오 재생이 중단됨
- `fadeOutDuration: 0.2`로 매우 짧아서 오디오가 재생될 시간이 부족함

---

## 해결 방법

### 선택한 방법: DontDestroyOnLoad 오브젝트에서 오디오 재생

**원리**: 씬 전환 후에도 파괴되지 않는 오브젝트에서 오디오를 재생하여, 씬 전환 중에도 오디오가 계속 재생되도록 함

**장점**:
- ✅ 씬 전환 후에도 오디오 재생 지속
- ✅ 페이드 아웃과 동시에 오디오 재생 가능
- ✅ 구현이 간단하고 직관적
- ✅ 기존 코드 구조를 크게 변경하지 않음

---

## 구현 계획

### 1. PlayClickSound() 메서드 수정

**변경 전**:
```csharp
private void PlayClickSound()
{
    if (clickSound == null) return;
    
    // AudioSource.PlayClipAtPoint를 사용하여 효과음 재생
    AudioSource.PlayClipAtPoint(clickSound, transform.position, soundVolume);
    Debug.Log($"[SceneTransitionArea] {gameObject.name}: 클릭 효과음 재생");
}
```

**변경 후**:
```csharp
private void PlayClickSound()
{
    if (clickSound == null) return;
    
    // DontDestroyOnLoad 오브젝트에서 오디오 재생
    PlaySoundWithDontDestroy(clickSound, soundVolume);
    Debug.Log($"[SceneTransitionArea] {gameObject.name}: 클릭 효과음 재생");
}

/// <summary>
/// DontDestroyOnLoad 오브젝트를 생성하여 오디오를 재생합니다.
/// 씬 전환 후에도 오디오가 계속 재생됩니다.
/// </summary>
private void PlaySoundWithDontDestroy(AudioClip clip, float volume)
{
    // 임시 오디오 오브젝트 생성
    GameObject audioObject = new GameObject("TempAudioSource");
    AudioSource audioSource = audioObject.AddComponent<AudioSource>();
    
    // AudioSource 설정
    audioSource.clip = clip;
    audioSource.volume = volume;
    audioSource.playOnAwake = false;
    audioSource.spatialBlend = 0f; // 2D 사운드 (3D 효과 비활성화)
    
    // DontDestroyOnLoad 설정 (씬 전환 후에도 유지)
    DontDestroyOnLoad(audioObject);
    
    // 오디오 재생
    audioSource.Play();
    
    // 재생 완료 후 오브젝트 자동 파괴 (코루틴 사용)
    StartCoroutine(DestroyAudioObjectWhenFinished(audioObject, clip.length));
}

/// <summary>
/// 오디오 재생이 완료되면 오브젝트를 파괴합니다.
/// </summary>
private System.Collections.IEnumerator DestroyAudioObjectWhenFinished(GameObject audioObject, float clipLength)
{
    // 오디오 클립 길이만큼 대기
    yield return new WaitForSeconds(clipLength);
    
    // 오브젝트 파괴
    if (audioObject != null)
    {
        Destroy(audioObject);
    }
}
```

### 2. 필요한 using 문 추가

```csharp
using System.Collections; // 코루틴 사용을 위해 추가
```

---

## 구현 단계

### Step 1: SceneTransitionArea.cs 수정

1. **using 문 추가**
   - 파일 상단에 `using System.Collections;` 추가

2. **PlayClickSound() 메서드 수정**
   - 기존 `AudioSource.PlayClipAtPoint()` 호출 제거
   - `PlaySoundWithDontDestroy()` 호출로 변경

3. **새로운 메서드 추가**
   - `PlaySoundWithDontDestroy()` 메서드 추가
   - `DestroyAudioObjectWhenFinished()` 코루틴 메서드 추가

### Step 2: 테스트

1. **Unity 에디터에서 테스트**
   - Play 모드 진입
   - `kitchentodoor` 오브젝트 클릭
   - 효과음이 페이드 아웃 중에도 들리는지 확인
   - 씬 전환 후에도 효과음이 완전히 재생되는지 확인

2. **콘솔 로그 확인**
   - "클릭 효과음 재생" 로그 출력 확인
   - 에러 메시지가 없는지 확인

3. **다른 씬 전환 오브젝트 테스트**
   - 다른 `SceneTransitionArea` 오브젝트들도 정상 작동하는지 확인
   - 여러 오브젝트를 빠르게 연속 클릭했을 때 문제가 없는지 확인

---

## 코드 변경 사항 요약

### 추가된 메서드

1. **PlaySoundWithDontDestroy()**
   - DontDestroyOnLoad 오브젝트 생성
   - AudioSource 설정 및 오디오 재생
   - 코루틴으로 자동 파괴 스케줄링

2. **DestroyAudioObjectWhenFinished()**
   - 오디오 재생 완료 후 오브젝트 파괴
   - 메모리 누수 방지

### 수정된 메서드

1. **PlayClickSound()**
   - `AudioSource.PlayClipAtPoint()` 제거
   - `PlaySoundWithDontDestroy()` 호출로 변경

### 추가된 using 문

- `using System.Collections;` (코루틴 사용)

---

## 기술적 세부사항

### DontDestroyOnLoad 동작 원리

- `DontDestroyOnLoad()`는 Unity의 특수 함수로, 씬 전환 시에도 오브젝트를 파괴하지 않음
- 오브젝트는 새 씬이 로드된 후에도 계속 존재
- 수동으로 파괴하거나 게임 종료 시까지 유지됨

### 오디오 재생 방식

- **기존 방식**: `AudioSource.PlayClipAtPoint()` - 임시 오브젝트 생성, 씬 전환 시 파괴
- **새 방식**: DontDestroyOnLoad 오브젝트의 AudioSource - 씬 전환 후에도 유지

### 메모리 관리

- 오디오 재생 완료 후 코루틴으로 오브젝트 자동 파괴
- 메모리 누수 방지
- 여러 오디오가 동시에 재생되어도 각각 독립적으로 관리됨

---

## 예상 결과

### 정상 동작 시나리오

1. 사용자가 `kitchentodoor` 오브젝트 클릭
2. 효과음 재생 시작 (DontDestroyOnLoad 오브젝트에서)
3. 페이드 아웃 시작 (0.2초)
4. **효과음이 페이드 아웃 중에도 계속 재생됨**
5. 씬 전환 (Kitchen 씬으로)
6. **효과음이 새 씬에서도 계속 재생됨**
7. 효과음 재생 완료 후 오브젝트 자동 파괴

### 개선 사항

- ✅ 씬 전환 중에도 효과음이 들림
- ✅ 페이드 아웃과 효과음이 동시에 재생됨
- ✅ 효과음이 완전히 재생됨
- ✅ 메모리 누수 없음

---

## 주의사항

### 1. 오디오 클립 길이

- 오디오 클립이 매우 길 경우 (예: 10초 이상), 새 씬에서도 계속 재생됨
- 짧은 효과음(1초 이하) 사용 권장

### 2. 동시 재생

- 여러 오브젝트를 빠르게 연속 클릭하면 여러 오디오가 동시에 재생될 수 있음
- 각 오디오는 독립적으로 관리되므로 문제 없음

### 3. 쿨다운 설정

- `clickCooldown` 설정으로 중복 클릭 방지 가능
- 기본값 0.1초로 설정되어 있음

---

## 테스트 체크리스트

- [ ] `kitchentodoor` 오브젝트 클릭 시 효과음 재생 확인
- [ ] 페이드 아웃 중에도 효과음이 들리는지 확인
- [ ] 씬 전환 후에도 효과음이 완전히 재생되는지 확인
- [ ] 콘솔에 에러 메시지가 없는지 확인
- [ ] 다른 씬 전환 오브젝트들도 정상 작동하는지 확인
- [ ] 연속 클릭 시 문제가 없는지 확인
- [ ] 오디오 오브젝트가 재생 완료 후 자동 파괴되는지 확인 (Hierarchy 창에서 확인)

---

## 참고사항

### 관련 파일

- `Assets/Scripts/Ryu/Gameplay/SceneTransitionArea.cs` - 수정 대상
- `Assets/Scripts/Ryu/Global/Utils/SceneFadeManager.cs` - 씬 전환 로직
- `Assets/Audio/Sound Effect/enter_sound.mp3` - 효과음 파일

### 관련 문서

- `마크다운/변경사항/0218/씬_전환_영역_클릭_시스템_구현_계획.md` - 초기 구현 계획
- `마크다운/변경사항/0218/배경음악_시스템_구현_계획.md` - AudioManager 참고

---

## 변경 이력

- **2026-02-19**: 씬 전환 시 효과음 재생 문제 해결 가이드 작성
- 문제 원인 분석 및 DontDestroyOnLoad 방식으로 해결 방법 제시

