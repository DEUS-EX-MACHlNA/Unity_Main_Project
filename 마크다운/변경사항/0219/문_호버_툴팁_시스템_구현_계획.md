# 문 호버 툴팁 시스템 구현 계획 (2026-02-19)

## 목표

### 요구사항
- Polygon Collider를 가진 "toDoor" 오브젝트들에 마우스를 올리면 문 정보를 표시
- 호버 시 목적지 씬 정보와 문 설명을 사용자에게 제공
- 기존 `SceneTransitionArea` 컴포넌트와 통합

### 현재 상황
- 프로젝트에 약 20개의 "toDoor" 오브젝트가 여러 씬에 분산되어 있음
- 모든 오브젝트가 `SceneTransitionArea` 컴포넌트와 `PolygonCollider2D`를 보유
- 이미 `OnMouseEnter()`와 `OnMouseExit()` 이벤트가 구현되어 있음
- `GameCanvas`가 모든 씬에 존재하며 Screen Space - Overlay 모드로 설정됨

---

## 해결 방법

### 선택한 방법: UI Canvas 기반 툴팁 시스템

**원리**: 기존 `GameCanvas` 하위에 툴팁 UI 패널을 추가하고, `SceneTransitionArea`에서 호버 이벤트 발생 시 툴팁 매니저를 통해 정보를 표시

**장점**:
- ✅ 기존 UI 시스템과 일관성 유지
- ✅ 텍스트, 아이콘, 이미지 등 다양한 정보 표시 가능
- ✅ 위치 조정 및 애니메이션 적용 용이
- ✅ 다국어 지원 용이
- ✅ 마우스 위치 추적이 간단함
- ✅ 화면 경계 처리 용이

---

## 구현 계획

### 1. DoorTooltipManager 스크립트 생성

**역할**: 툴팁 UI를 관리하는 싱글톤 매니저

**파일 위치**: `Assets/Scripts/Ryu/UI/DoorTooltipManager.cs`

**주요 기능**:
- 툴팁 UI 표시/숨김 제어
- 마우스 위치에 따른 툴팁 위치 자동 조정
- 페이드 인/아웃 애니메이션
- 문 정보 텍스트 업데이트

**코드 구조**:
```csharp
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System.Collections;

/// <summary>
/// 문 오브젝트 호버 시 툴팁을 표시하는 매니저입니다.
/// 싱글톤 패턴을 사용합니다.
/// </summary>
public class DoorTooltipManager : MonoBehaviour
{
    public static DoorTooltipManager Instance { get; private set; }
    
    [Header("UI References")]
    [SerializeField] private GameObject tooltipPanel;
    [SerializeField] private TextMeshProUGUI titleText;
    [SerializeField] private TextMeshProUGUI descriptionText;
    [SerializeField] private Image backgroundImage;
    
    [Header("Settings")]
    [Tooltip("호버 후 툴팁이 나타나기까지의 지연 시간 (초)")]
    [SerializeField] private float showDelay = 0.3f;
    
    [Tooltip("툴팁과 마우스 커서 사이의 오프셋 (픽셀)")]
    [SerializeField] private Vector2 cursorOffset = new Vector2(20, 20);
    
    [Tooltip("툴팁 배경 색상")]
    [SerializeField] private Color backgroundColor = new Color(0, 0, 0, 0.8f);
    
    private RectTransform tooltipRectTransform;
    private Canvas canvas;
    private Coroutine showTooltipCoroutine;
    private bool isShowing = false;
    
    private void Awake()
    {
        // 싱글톤 설정
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
            return;
        }
        
        // 컴포넌트 초기화
        if (tooltipPanel != null)
        {
            tooltipRectTransform = tooltipPanel.GetComponent<RectTransform>();
            tooltipPanel.SetActive(false);
        }
        
        canvas = GetComponentInParent<Canvas>();
        
        // 배경 색상 설정
        if (backgroundImage != null)
        {
            backgroundImage.color = backgroundColor;
        }
    }
    
    /// <summary>
    /// 툴팁을 표시합니다.
    /// </summary>
    /// <param name="title">문 제목 (예: "거실로 이동")</param>
    /// <param name="description">문 설명 (예: "거실로 가는 문입니다")</param>
    public void ShowTooltip(string title, string description)
    {
        if (tooltipPanel == null || titleText == null || descriptionText == null)
        {
            Debug.LogWarning("[DoorTooltipManager] UI 참조가 설정되지 않았습니다.");
            return;
        }
        
        // 기존 코루틴 중지
        if (showTooltipCoroutine != null)
        {
            StopCoroutine(showTooltipCoroutine);
        }
        
        showTooltipCoroutine = StartCoroutine(ShowTooltipCoroutine(title, description));
    }
    
    /// <summary>
    /// 툴팁을 숨깁니다.
    /// </summary>
    public void HideTooltip()
    {
        if (showTooltipCoroutine != null)
        {
            StopCoroutine(showTooltipCoroutine);
            showTooltipCoroutine = null;
        }
        
        if (tooltipPanel != null && isShowing)
        {
            StartCoroutine(HideTooltipCoroutine());
        }
    }
    
    private IEnumerator ShowTooltipCoroutine(string title, string description)
    {
        // 지연 시간 대기
        yield return new WaitForSeconds(showDelay);
        
        // 텍스트 업데이트
        titleText.text = title;
        descriptionText.text = description;
        
        // 위치 설정
        UpdateTooltipPosition();
        
        // 툴팁 활성화 및 페이드 인
        tooltipPanel.SetActive(true);
        isShowing = true;
        
        // 페이드 인 애니메이션
        CanvasGroup canvasGroup = tooltipPanel.GetComponent<CanvasGroup>();
        if (canvasGroup == null)
        {
            canvasGroup = tooltipPanel.AddComponent<CanvasGroup>();
        }
        
        canvasGroup.alpha = 0f;
        float fadeDuration = 0.2f;
        float elapsed = 0f;
        
        while (elapsed < fadeDuration)
        {
            elapsed += Time.deltaTime;
            canvasGroup.alpha = Mathf.Lerp(0f, 1f, elapsed / fadeDuration);
            yield return null;
        }
        
        canvasGroup.alpha = 1f;
    }
    
    private IEnumerator HideTooltipCoroutine()
    {
        CanvasGroup canvasGroup = tooltipPanel.GetComponent<CanvasGroup>();
        if (canvasGroup == null)
        {
            tooltipPanel.SetActive(false);
            isShowing = false;
            yield break;
        }
        
        // 페이드 아웃 애니메이션
        float fadeDuration = 0.15f;
        float elapsed = 0f;
        float startAlpha = canvasGroup.alpha;
        
        while (elapsed < fadeDuration)
        {
            elapsed += Time.deltaTime;
            canvasGroup.alpha = Mathf.Lerp(startAlpha, 0f, elapsed / fadeDuration);
            yield return null;
        }
        
        canvasGroup.alpha = 0f;
        tooltipPanel.SetActive(false);
        isShowing = false;
    }
    
    /// <summary>
    /// 마우스 위치에 따라 툴팁 위치를 업데이트합니다.
    /// </summary>
    private void UpdateTooltipPosition()
    {
        if (tooltipRectTransform == null || canvas == null) return;
        
        // 마우스 스크린 좌표를 Canvas 좌표로 변환
        Vector2 mousePosition;
        RectTransformUtility.ScreenPointToLocalPointInRectangle(
            canvas.transform as RectTransform,
            Input.mousePosition,
            canvas.worldCamera,
            out mousePosition);
        
        // 오프셋 적용
        mousePosition += cursorOffset;
        
        // 화면 경계 체크 및 조정
        RectTransform canvasRect = canvas.transform as RectTransform;
        Vector2 tooltipSize = tooltipRectTransform.sizeDelta;
        
        // 오른쪽 경계 체크
        if (mousePosition.x + tooltipSize.x > canvasRect.sizeDelta.x / 2)
        {
            mousePosition.x = canvasRect.sizeDelta.x / 2 - tooltipSize.x - cursorOffset.x;
        }
        
        // 위쪽 경계 체크
        if (mousePosition.y + tooltipSize.y > canvasRect.sizeDelta.y / 2)
        {
            mousePosition.y = canvasRect.sizeDelta.y / 2 - tooltipSize.y - cursorOffset.y;
        }
        
        // 왼쪽 경계 체크
        if (mousePosition.x < -canvasRect.sizeDelta.x / 2)
        {
            mousePosition.x = -canvasRect.sizeDelta.x / 2 + cursorOffset.x;
        }
        
        // 아래쪽 경계 체크
        if (mousePosition.y < -canvasRect.sizeDelta.y / 2)
        {
            mousePosition.y = -canvasRect.sizeDelta.y / 2 + cursorOffset.y;
        }
        
        tooltipRectTransform.anchoredPosition = mousePosition;
    }
    
    private void Update()
    {
        // 툴팁이 표시 중일 때 마우스 위치 추적
        if (isShowing && tooltipPanel.activeSelf)
        {
            UpdateTooltipPosition();
        }
    }
}
```

### 2. SceneTransitionArea.cs 수정

**변경 사항**: 호버 이벤트에서 툴팁 매니저 호출 추가

**추가할 필드**:
```csharp
[Header("Tooltip")]
[Tooltip("툴팁에 표시할 문 제목 (예: '거실로 이동')")]
[SerializeField] private string tooltipTitle;

[Tooltip("툴팁에 표시할 문 설명 (예: '거실로 가는 문입니다')")]
[SerializeField] private string tooltipDescription;

[Tooltip("툴팁 표시 여부")]
[SerializeField] private bool showTooltip = true;
```

**수정할 메서드**:
```csharp
private void OnMouseEnter()
{
    isHovering = true;
    
    // 하이라이트 효과
    if (useHighlight && spriteRenderer != null)
    {
        spriteRenderer.color = highlightColor;
    }
    
    // 커서 변경
    ChangeCursor(true);
    
    // 툴팁 표시
    if (showTooltip && DoorTooltipManager.Instance != null)
    {
        // tooltipTitle이 비어있으면 목적지 씬 이름 사용
        string title = string.IsNullOrEmpty(tooltipTitle) 
            ? $"{targetSceneName}로 이동" 
            : tooltipTitle;
        
        // tooltipDescription이 비어있으면 기본 메시지 사용
        string description = string.IsNullOrEmpty(tooltipDescription)
            ? "클릭하여 이동합니다"
            : tooltipDescription;
        
        DoorTooltipManager.Instance.ShowTooltip(title, description);
    }
}

private void OnMouseExit()
{
    isHovering = false;
    
    // 하이라이트 복원
    if (useHighlight && spriteRenderer != null)
    {
        spriteRenderer.color = originalColor;
    }
    
    // 커서 복원
    ChangeCursor(false);
    
    // 툴팁 숨김
    if (showTooltip && DoorTooltipManager.Instance != null)
    {
        DoorTooltipManager.Instance.HideTooltip();
    }
}

private void OnDisable()
{
    // GameObject가 비활성화될 때 툴팁도 숨김
    if (isHovering && DoorTooltipManager.Instance != null)
    {
        DoorTooltipManager.Instance.HideTooltip();
    }
    
    // 커서 복원
    if (isHovering)
    {
        RestoreDefaultCursor();
    }
}
```

---

## 구현 단계

### Step 1: DoorTooltipManager 스크립트 생성

1. **스크립트 파일 생성**
   - 경로: `Assets/Scripts/Ryu/UI/DoorTooltipManager.cs`
   - 위의 코드 구조대로 작성

2. **필요한 using 문 확인**
   - `using UnityEngine;`
   - `using UnityEngine.UI;`
   - `using TMPro;` (TextMeshPro 사용 시)
   - `using System.Collections;` (코루틴 사용)

### Step 2: UI 구조 생성

1. **GameCanvas 하위에 TooltipPanel 생성**
   - Hierarchy에서 `GameCanvas` 선택
   - 우클릭 → UI → Panel → 이름을 "TooltipPanel"로 변경

2. **TooltipPanel 설정**
   - RectTransform: Anchor Presets를 "Bottom-Left"로 설정
   - Image 컴포넌트: 배경 색상 설정 (검은색 반투명 권장)
   - CanvasGroup 컴포넌트 추가 (페이드 효과용)
   - 초기 상태: `SetActive(false)`

3. **TitleText 생성**
   - TooltipPanel 하위에 UI → Text - TextMeshPro 생성
   - 이름: "TitleText"
   - 폰트 크기: 18-20
   - 정렬: 중앙 정렬
   - 색상: 흰색

4. **DescriptionText 생성**
   - TooltipPanel 하위에 UI → Text - TextMeshPro 생성
   - 이름: "DescriptionText"
   - 폰트 크기: 14-16
   - 정렬: 중앙 정렬
   - 색상: 연한 회색

5. **레이아웃 구성**
   - Vertical Layout Group 추가 (선택적, 자동 정렬용)
   - Content Size Fitter 추가 (텍스트 길이에 따라 자동 크기 조정)

### Step 3: DoorTooltipManager 오브젝트 생성

1. **GameCanvas 하위에 빈 GameObject 생성**
   - 이름: "DoorTooltipManager"
   - DoorTooltipManager 컴포넌트 추가

2. **Inspector 설정**
   - Tooltip Panel: 위에서 생성한 TooltipPanel 드래그
   - Title Text: TitleText 드래그
   - Description Text: DescriptionText 드래그
   - Background Image: TooltipPanel의 Image 컴포넌트 드래그
   - Show Delay: 0.3 (초)
   - Cursor Offset: (20, 20)
   - Background Color: (0, 0, 0, 0.8)

### Step 4: SceneTransitionArea.cs 수정

1. **필드 추가**
   - `tooltipTitle` 필드 추가
   - `tooltipDescription` 필드 추가
   - `showTooltip` 필드 추가

2. **OnMouseEnter() 수정**
   - 툴팁 표시 로직 추가

3. **OnMouseExit() 수정**
   - 툴팁 숨김 로직 추가

4. **OnDisable() 수정**
   - 툴팁 숨김 로직 추가

### Step 5: 씬별 설정

1. **각 씬의 GameCanvas 확인**
   - 모든 씬에 GameCanvas가 있는지 확인
   - 없으면 생성 또는 프리팹 인스턴스화

2. **각 toDoor 오브젝트 설정**
   - Inspector에서 `tooltipTitle` 설정 (예: "거실로 이동")
   - Inspector에서 `tooltipDescription` 설정 (예: "거실로 가는 문입니다")
   - `showTooltip` 체크 확인

### Step 6: 프리팹화 (선택적)

1. **TooltipPanel 프리팹 생성**
   - TooltipPanel을 Assets/Prefabs/UI/로 드래그하여 프리팹 생성

2. **DoorTooltipManager 프리팹 생성**
   - DoorTooltipManager 오브젝트를 프리팹화

3. **씬에 프리팹 배치**
   - 각 씬의 GameCanvas 하위에 프리팹 인스턴스 배치

---

## 코드 변경 사항 요약

### 새로 생성되는 파일

1. **DoorTooltipManager.cs**
   - 위치: `Assets/Scripts/Ryu/UI/DoorTooltipManager.cs`
   - 역할: 툴팁 UI 관리 싱글톤 매니저

### 수정되는 파일

1. **SceneTransitionArea.cs**
   - 위치: `Assets/Scripts/Ryu/Gameplay/SceneTransitionArea.cs`
   - 변경 내용:
     - `tooltipTitle`, `tooltipDescription`, `showTooltip` 필드 추가
     - `OnMouseEnter()`에 툴팁 표시 로직 추가
     - `OnMouseExit()`에 툴팁 숨김 로직 추가
     - `OnDisable()`에 툴팁 숨김 로직 추가

### 새로 생성되는 UI 요소

1. **TooltipPanel** (GameCanvas 하위)
   - Image 컴포넌트 (배경)
   - CanvasGroup 컴포넌트 (페이드 효과)
   - TitleText (TextMeshProUGUI)
   - DescriptionText (TextMeshProUGUI)

2. **DoorTooltipManager** (GameCanvas 하위)
   - DoorTooltipManager 컴포넌트

---

## 기술적 세부사항

### 싱글톤 패턴

- `DoorTooltipManager`는 싱글톤으로 구현
- `DontDestroyOnLoad`를 사용하여 씬 전환 후에도 유지
- 모든 씬에서 동일한 인스턴스 사용

### 좌표 변환

- `RectTransformUtility.ScreenPointToLocalPointInRectangle()` 사용
- 마우스 스크린 좌표를 Canvas 로컬 좌표로 변환
- 화면 경계 체크 및 자동 위치 조정

### 애니메이션

- CanvasGroup의 alpha 값을 이용한 페이드 인/아웃
- 코루틴을 사용한 부드러운 전환
- 표시 지연 시간 적용 (0.3초)

### 마우스 위치 추적

- `Update()`에서 지속적으로 마우스 위치 추적
- 툴팁이 표시 중일 때만 업데이트하여 성능 최적화

---

## 예상 결과

### 정상 동작 시나리오

1. 사용자가 "toDoor" 오브젝트에 마우스를 올림
2. 0.3초 후 툴팁이 페이드 인 애니메이션과 함께 표시됨
3. 툴팁이 마우스 커서 근처에 위치하며, 화면 경계를 벗어나지 않도록 자동 조정됨
4. 툴팁에 문 제목과 설명이 표시됨
5. 사용자가 마우스를 벗어나면 툴팁이 페이드 아웃 애니메이션과 함께 사라짐
6. 씬 전환 시에도 툴팁이 정상적으로 숨겨짐

### 개선 사항

- ✅ 호버 시 문 정보를 명확하게 표시
- ✅ 부드러운 애니메이션으로 사용자 경험 향상
- ✅ 화면 경계 자동 처리로 가독성 보장
- ✅ 기존 시스템과의 통합으로 일관성 유지

---

## 주의사항

### 1. TextMeshPro 의존성

- TextMeshPro 패키지가 프로젝트에 설치되어 있어야 함
- 없으면 일반 `Text` 컴포넌트로 대체 가능 (코드 수정 필요)

### 2. 씬별 DoorTooltipManager 설정

- 각 씬의 GameCanvas에 DoorTooltipManager가 있어야 함
- 또는 DontDestroyOnLoad로 한 씬에만 배치하고 다른 씬에서도 사용

### 3. 툴팁 표시 지연

- `showDelay` 설정으로 호버 후 지연 시간 조정 가능
- 너무 짧으면 의도치 않은 툴팁 표시 가능
- 너무 길면 사용자 경험이 저하될 수 있음

### 4. 다중 툴팁 방지

- 현재 구현은 한 번에 하나의 툴팁만 표시
- 여러 오브젝트를 빠르게 호버해도 마지막 호버만 표시됨

### 5. 씬 전환 시 정리

- `OnDisable()`에서 툴팁을 숨겨 씬 전환 시 깔끔하게 처리
- DontDestroyOnLoad를 사용하므로 씬 전환 후에도 매니저는 유지됨

---

## 테스트 체크리스트

### 기본 기능 테스트

- [ ] "toDoor" 오브젝트에 마우스를 올리면 툴팁이 표시되는지 확인
- [ ] 툴팁에 설정한 제목과 설명이 올바르게 표시되는지 확인
- [ ] 마우스를 벗어나면 툴팁이 사라지는지 확인
- [ ] 페이드 인/아웃 애니메이션이 부드럽게 작동하는지 확인

### 위치 및 경계 테스트

- [ ] 툴팁이 마우스 커서 근처에 표시되는지 확인
- [ ] 화면 오른쪽 경계에서 툴팁이 잘리지 않는지 확인
- [ ] 화면 위쪽 경계에서 툴팁이 잘리지 않는지 확인
- [ ] 화면 왼쪽/아래쪽 경계에서도 정상 작동하는지 확인

### 씬 전환 테스트

- [ ] 씬 전환 시 툴팁이 자동으로 숨겨지는지 확인
- [ ] 새 씬에서도 툴팁이 정상 작동하는지 확인
- [ ] DoorTooltipManager가 씬 전환 후에도 유지되는지 확인

### 다양한 오브젝트 테스트

- [ ] 모든 "toDoor" 오브젝트에서 툴팁이 표시되는지 확인
- [ ] tooltipTitle이 비어있을 때 기본 제목이 표시되는지 확인
- [ ] tooltipDescription이 비어있을 때 기본 설명이 표시되는지 확인
- [ ] showTooltip이 false일 때 툴팁이 표시되지 않는지 확인

### 성능 테스트

- [ ] 여러 오브젝트를 빠르게 호버해도 문제가 없는지 확인
- [ ] 툴팁 표시 중에도 게임이 부드럽게 실행되는지 확인
- [ ] 메모리 누수가 없는지 확인 (프로파일러 사용)

---

## 참고사항

### 관련 파일

- `Assets/Scripts/Ryu/Gameplay/SceneTransitionArea.cs` - 수정 대상
- `Assets/Scripts/Ryu/UI/DoorTooltipManager.cs` - 새로 생성
- `Assets/Prefabs/UI/GameCanvas.prefab` - UI 구조 참고

### 관련 문서

- `마크다운/변경사항/0219/씬_전환_시_효과음_재생_문제_해결.md` - SceneTransitionArea 참고
- `마크다운/변경사항/0208/HoverGlow_효과.md` - 호버 효과 참고

### 대안 구현 방법

1. **World Space Canvas 사용**
   - 문 오브젝트 위에 직접 툴팁 배치
   - 카메라를 향해 항상 정면 표시
   - 구현이 더 복잡하지만 3D 공간에서 자연스러움

2. **기존 UI Toolkit 활용**
   - 프로젝트의 UI Toolkit Tooltip 시스템 사용
   - 월드 오브젝트와의 연동이 복잡할 수 있음

3. **Sprite 기반 툴팁**
   - 툴팁을 스프라이트로 제작
   - 2D 게임에 자연스러움
   - 텍스트 변경이 어려움

---

## 변경 이력

- **2026-02-19**: 문 호버 툴팁 시스템 구현 계획 작성
- UI Canvas 기반 툴팁 시스템 설계 및 구현 단계 정리

