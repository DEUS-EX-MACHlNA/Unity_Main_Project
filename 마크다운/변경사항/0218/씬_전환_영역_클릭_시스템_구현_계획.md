# 씬 전환 영역 클릭 시스템 구현 계획 (2026-02-18)

## 개요
씬의 특정 영역을 클릭하면 다른 씬으로 전환하는 시스템을 구현합니다. 2D 월드 공간의 Collider 영역을 클릭하면 페이드 아웃 효과와 함께 목적지 씬으로 이동하며, 호버 시 하이라이트 효과와 클릭 시 효과음을 제공합니다.

## 구현 목표

### 1. 핵심 기능
- 2D Collider 영역 클릭 감지 (OnMouseDown 사용)
- 클릭 시 페이드 아웃 후 씬 전환
- 호버 시 하이라이트 효과 (SpriteRenderer 색상 변경)
- 클릭 시 효과음 재생
- 각 영역에 개별 스크립트 컴포넌트 부착 방식
- 다중 영역 지원 (2~5개)

### 2. 기술 요구사항
- BoxCollider2D 필수 요구
- SceneFadeManager를 통한 페이드 아웃 및 씬 전환
- AudioManager를 통한 효과음 재생
- 인스펙터에서 목적지 씬 이름 설정 가능
- 기존 ClickableObject와 유사한 구조 유지

## 구현 계획

### 1. SceneTransitionArea 스크립트 생성

**파일 위치**: `Assets/Scripts/Ryu/Gameplay/SceneTransitionArea.cs`

**주요 기능**:
- BoxCollider2D 필수 요구
- OnMouseDown()으로 클릭 감지
- 호버 시 하이라이트 효과 (OnMouseEnter/OnMouseExit)
- 클릭 시 효과음 재생
- 페이드 아웃 후 씬 전환

**주요 변수**:
```csharp
[Header("Scene Transition Settings")]
[SerializeField] private string targetSceneName;  // 목적지 씬 이름
[SerializeField] private float fadeDuration = 1f;  // 페이드 아웃 지속 시간

[Header("Visual Feedback")]
[SerializeField] private Color highlightColor = new Color(1f, 1f, 0.5f, 1f);  // 호버 시 하이라이트 색상
[SerializeField] private bool useHighlight = true;  // 하이라이트 사용 여부

[Header("Audio")]
[SerializeField] private AudioClip clickSound;  // 클릭 시 재생할 효과음 (선택적)
[SerializeField] private float soundVolume = 1f;  // 효과음 볼륨

[Header("Settings")]
[SerializeField] private float clickCooldown = 0.1f;  // 중복 클릭 방지 쿨다운
```

**주요 메서드**:
- `OnMouseDown()`: 클릭 감지 및 씬 전환 처리
- `OnMouseEnter()`: 호버 시 하이라이트 적용
- `OnMouseExit()`: 호버 해제 시 원래 색상 복원
- `TransitionToScene()`: 씬 전환 로직 실행

**코드 구조**:
```csharp
using UnityEngine;

/// <summary>
/// 씬의 특정 영역을 클릭하면 다른 씬으로 전환하는 컴포넌트입니다.
/// BoxCollider2D가 필요합니다.
/// </summary>
[RequireComponent(typeof(BoxCollider2D))]
public class SceneTransitionArea : MonoBehaviour
{
    [Header("Scene Transition Settings")]
    [Tooltip("전환할 목적지 씬 이름 (Build Settings에 등록된 씬 이름)")]
    [SerializeField] private string targetSceneName;
    
    [Tooltip("페이드 아웃 지속 시간 (초)")]
    [SerializeField] private float fadeDuration = 1f;
    
    [Header("Visual Feedback")]
    [Tooltip("호버 시 하이라이트 색상")]
    [SerializeField] private Color highlightColor = new Color(1f, 1f, 0.5f, 1f);
    
    [Tooltip("하이라이트 효과 사용 여부")]
    [SerializeField] private bool useHighlight = true;
    
    [Header("Audio")]
    [Tooltip("클릭 시 재생할 효과음 (선택적, 비어있으면 재생 안 함)")]
    [SerializeField] private AudioClip clickSound;
    
    [Tooltip("효과음 볼륨")]
    [SerializeField] [Range(0f, 1f)] private float soundVolume = 1f;
    
    [Header("Settings")]
    [Tooltip("중복 클릭 방지 쿨다운 (초)")]
    [SerializeField] private float clickCooldown = 0.1f;
    
    private SpriteRenderer spriteRenderer;
    private Color originalColor;
    private float lastClickTime;
    private bool isHovering = false;
    
    private void Awake()
    {
        // SpriteRenderer 찾기 (있으면 하이라이트 사용)
        spriteRenderer = GetComponent<SpriteRenderer>();
        if (spriteRenderer != null)
        {
            originalColor = spriteRenderer.color;
        }
        else
        {
            // SpriteRenderer가 없으면 하이라이트 비활성화
            useHighlight = false;
            Debug.LogWarning($"[SceneTransitionArea] {gameObject.name}: SpriteRenderer를 찾을 수 없습니다. 하이라이트 효과가 비활성화됩니다.");
        }
    }
    
    private void OnMouseEnter()
    {
        if (!useHighlight || spriteRenderer == null) return;
        
        isHovering = true;
        spriteRenderer.color = highlightColor;
    }
    
    private void OnMouseExit()
    {
        if (!useHighlight || spriteRenderer == null) return;
        
        isHovering = false;
        spriteRenderer.color = originalColor;
    }
    
    private void OnMouseDown()
    {
        // 쿨다운 체크
        if (Time.time - lastClickTime < clickCooldown)
            return;
        
        lastClickTime = Time.time;
        
        // 목적지 씬 이름 확인
        if (string.IsNullOrEmpty(targetSceneName))
        {
            Debug.LogError($"[SceneTransitionArea] {gameObject.name}: 목적지 씬 이름이 설정되지 않았습니다.");
            return;
        }
        
        // 효과음 재생
        PlayClickSound();
        
        // 씬 전환
        TransitionToScene();
    }
    
    private void PlayClickSound()
    {
        if (clickSound == null) return;
        
        // AudioManager가 있으면 사용, 없으면 직접 재생
        if (AudioManager.Instance != null)
        {
            // AudioManager에 효과음 재생 메서드가 있다면 사용
            // 현재는 AudioManager가 배경음악만 관리하므로, 직접 AudioSource.PlayClipAtPoint 사용
            AudioSource.PlayClipAtPoint(clickSound, transform.position, soundVolume);
        }
        else
        {
            AudioSource.PlayClipAtPoint(clickSound, transform.position, soundVolume);
        }
        
        Debug.Log($"[SceneTransitionArea] {gameObject.name}: 클릭 효과음 재생");
    }
    
    private void TransitionToScene()
    {
        Debug.Log($"[SceneTransitionArea] {gameObject.name}: {targetSceneName} 씬으로 전환 시작");
        
        // SceneFadeManager 찾기
        SceneFadeManager fadeManager = FindFirstObjectByType<SceneFadeManager>();
        
        if (fadeManager != null)
        {
            // 페이드 아웃 후 씬 전환 (페이드 인은 SceneFadeManager.Start()에서 자동 처리)
            fadeManager.LoadSceneWithFade(targetSceneName, fadeDuration);
        }
        else
        {
            // SceneFadeManager가 없으면 페이드 없이 즉시 전환
            Debug.LogWarning($"[SceneTransitionArea] SceneFadeManager를 찾을 수 없습니다. 페이드 없이 씬을 전환합니다.");
            SceneManager.LoadScene(targetSceneName);
        }
    }
}
```

### 2. 기존 시스템 활용

**SceneFadeManager 활용**:
- `LoadSceneWithFade(string sceneName, float fadeDuration)` 메서드 사용
- 페이드 아웃만 사용 (페이드 인은 SceneFadeManager.Start()에서 자동 처리)
- 씬 로드 실패 시 자동 복구 처리

**AudioManager 활용**:
- 효과음 재생은 `AudioSource.PlayClipAtPoint()` 사용 (간단한 효과음이므로)
- 향후 AudioManager에 효과음 시스템이 추가되면 연동 가능

**ClickableObject 참고**:
- OnMouseDown() 사용 방식 동일
- 쿨다운 처리 방식 동일
- RequireComponent 패턴 동일

### 3. 사용 방법

**씬에 클릭 가능한 영역 추가**:
1. 씬에 빈 GameObject 생성 (또는 기존 Sprite GameObject 사용)
2. `BoxCollider2D` 컴포넌트 추가 (자동 추가됨)
3. `SceneTransitionArea` 컴포넌트 추가
4. Inspector에서 설정:
   - `Target Scene Name`: 전환할 씬 이름 입력
   - `Fade Duration`: 페이드 아웃 시간 설정
   - `Highlight Color`: 호버 시 색상 설정
   - `Click Sound`: 효과음 클립 할당 (선택적)
5. Collider 크기 조정하여 클릭 가능 영역 설정

**SpriteRenderer가 있는 경우**:
- 하이라이트 효과 자동 적용
- 원래 색상 자동 저장 및 복원

**SpriteRenderer가 없는 경우**:
- 하이라이트 효과 비활성화
- Collider만으로 클릭 감지

### 4. 다중 영역 관리

**각 영역에 개별 컴포넌트 부착**:
- 각 클릭 가능한 영역(GameObject)에 `SceneTransitionArea` 컴포넌트 부착
- 각 컴포넌트에서 독립적으로 목적지 씬 설정
- 예: Door1 → "Hallway", Door2 → "Kitchen"

**장점**:
- 간단하고 직관적
- 인스펙터에서 쉽게 설정 가능
- 각 영역별로 독립적인 설정 가능

## 기술적 세부사항

### OnMouseDown() 작동 조건
- GameObject에 Collider2D가 있어야 함
- Camera의 Ray가 Collider를 감지할 수 있어야 함
- 2D 씬의 경우 Camera의 Projection이 Orthographic이어야 함
- Collider의 IsTrigger는 false여야 함 (물리 감지용)

### 하이라이트 효과 구현
- `OnMouseEnter()`: 마우스가 영역에 들어올 때 SpriteRenderer 색상 변경
- `OnMouseExit()`: 마우스가 영역을 벗어날 때 원래 색상 복원
- SpriteRenderer가 없으면 하이라이트 비활성화

### 페이드 아웃 처리
- SceneFadeManager의 `LoadSceneWithFade()` 사용
- 페이드 아웃만 수행 (페이드 인은 새 씬의 SceneFadeManager.Start()에서 자동 처리)
- 씬 로드 실패 시 자동 복구 (SceneFadeManager 내부 처리)

### 효과음 재생
- `AudioSource.PlayClipAtPoint()` 사용
- 3D 공간에서 재생되므로 위치 기반 볼륨 조절
- AudioManager가 있으면 향후 연동 가능하도록 구조 준비

### 쿨다운 처리
- 중복 클릭 방지를 위한 시간 체크
- `Time.time`을 사용한 간단한 쿨다운 구현
- 기본값 0.1초 (인스펙터에서 조정 가능)

## 구현 단계

### Phase 1: 기본 스크립트 생성
1. `SceneTransitionArea.cs` 스크립트 생성
2. 기본 구조 및 변수 선언
3. OnMouseDown() 클릭 감지 구현
4. 씬 전환 로직 구현 (SceneFadeManager 연동)

### Phase 2: 시각적 피드백 추가
1. OnMouseEnter/OnMouseExit 구현
2. 하이라이트 색상 적용 로직
3. SpriteRenderer 자동 감지 및 처리

### Phase 3: 효과음 추가
1. 효과음 재생 로직 구현
2. AudioClip 필드 추가
3. 볼륨 설정 추가

### Phase 4: 테스트 및 최적화
1. 다양한 씬에서 테스트
2. 에러 처리 강화
3. 로그 메시지 정리

## 사용 시나리오

### 시나리오 1: 방의 문 클릭하여 다른 방으로 이동
```
1. PlayersRoom 씬에 Door GameObject 생성
2. BoxCollider2D 추가 (자동)
3. SceneTransitionArea 컴포넌트 추가
4. Target Scene Name을 "Hallway"로 설정
5. Collider 크기를 문 크기에 맞게 조정
6. 플레이어가 문을 클릭하면 Hallway 씬으로 전환
```

### 시나리오 2: 여러 개의 문이 있는 방
```
1. LivingRoom 씬에 Door1, Door2, Door3 GameObject 생성
2. 각각에 SceneTransitionArea 컴포넌트 추가
3. Door1 → "Kitchen", Door2 → "Hallway", Door3 → "Basement" 설정
4. 각 문을 클릭하면 해당 씬으로 전환
```

### 시나리오 3: 호버 효과가 있는 클릭 영역
```
1. SpriteRenderer가 있는 GameObject에 SceneTransitionArea 추가
2. Highlight Color를 노란색(1, 1, 0.5)으로 설정
3. 마우스를 올리면 하이라이트 표시
4. 클릭하면 씬 전환
```

### 시나리오 4: 효과음이 있는 클릭 영역
```
1. SceneTransitionArea 컴포넌트 추가
2. Click Sound 필드에 효과음 AudioClip 할당
3. 클릭 시 효과음 재생 후 씬 전환
```

## 확장 가능성

### 향후 개선 사항
1. **조건부 전환**: 특정 조건 만족 시에만 씬 전환 가능
2. **애니메이션 효과**: 클릭 시 오브젝트 애니메이션 (예: 문 열리는 애니메이션)
3. **확인 다이얼로그**: 클릭 시 "정말 이동하시겠습니까?" 확인 창
4. **데이터 전달**: 씬 전환 시 특정 데이터 전달
5. **이벤트 시스템**: 씬 전환 전/후 이벤트 콜백
6. **디버그 모드**: 에디터에서 클릭 영역 시각화 (Gizmo)

### AudioManager 연동
- 향후 AudioManager에 효과음 시스템이 추가되면 연동
- `AudioManager.Instance.PlaySFX(clickSound)` 형태로 변경 가능

### SceneFadeManager 확장
- 페이드 인/아웃 시간을 각각 설정 가능하도록 확장
- 커스텀 페이드 효과 추가 가능

## 테스트 계획

### 1. 기본 기능 테스트
- [ ] 클릭 시 씬 전환 정상 작동 확인
- [ ] 페이드 아웃 효과 정상 작동 확인
- [ ] 목적지 씬 이름이 비어있을 때 에러 처리 확인
- [ ] 씬 이름이 잘못되었을 때 에러 처리 확인

### 2. 시각적 피드백 테스트
- [ ] 호버 시 하이라이트 효과 확인
- [ ] 호버 해제 시 원래 색상 복원 확인
- [ ] SpriteRenderer가 없을 때 처리 확인

### 3. 효과음 테스트
- [ ] 효과음 재생 확인
- [ ] 효과음이 없을 때 처리 확인
- [ ] 볼륨 설정 확인

### 4. 다중 영역 테스트
- [ ] 여러 영역이 있을 때 각각 정상 작동 확인
- [ ] 각 영역이 다른 씬으로 전환되는지 확인

### 5. 예외 상황 테스트
- [ ] SceneFadeManager가 없을 때 처리 확인
- [ ] 씬이 Build Settings에 없을 때 처리 확인
- [ ] 연속 클릭 시 쿨다운 작동 확인

## 참고사항

### BoxCollider2D 설정
- `Is Trigger`는 false로 설정 (물리 감지용)
- `Size`를 클릭 가능한 영역 크기에 맞게 조정
- `Offset`으로 위치 조정 가능

### 씬 이름 설정
- Build Settings에 등록된 씬 이름과 정확히 일치해야 함
- 대소문자 구분
- 확장자(.unity) 없이 씬 이름만 입력

### 하이라이트 색상
- 기본값: 노란색 계열 (1, 1, 0.5)
- 인스펙터에서 자유롭게 변경 가능
- 투명도(Alpha)는 변경하지 않는 것이 좋음 (원래 색상 유지)

### 효과음 파일
- AudioClip 형식 (.mp3, .ogg, .wav 등)
- Resources 폴더에 넣거나 직접 할당
- 짧은 효과음 권장 (1초 이하)

### 성능 고려사항
- OnMouseDown()은 가벼운 작업
- 하이라이트 효과는 색상 변경만 수행 (비용 낮음)
- 효과음은 PlayClipAtPoint 사용 (임시 AudioSource 생성)

### 기존 시스템과의 호환성
- ClickableObject와 동일한 패턴 사용
- SceneFadeManager와 완벽 호환
- AudioManager와 향후 연동 가능한 구조

