# 다음 단계 상세 가이드

이 문서는 방 씬 생성 시스템 구축 완료 후 다음 단계 작업에 대한 상세 가이드를 제공합니다.

## 목차

1. [새 방 씬 생성](#1-새-방-씬-생성)
2. [NPC 상태 동기화 시스템 구현](#2-npc-상태-동기화-시스템-구현)
3. [아이템 상태 동기화 시스템 구현](#3-아이템-상태-동기화-시스템-구현)

---

## 1. 새 방 씬 생성

### 작업 유형: **대부분 수동 작업** (Unity 에디터)

### 개요

시나리오에 명시된 7개 방 씬을 생성합니다:
- 주인공의 방 (PlayersRoom)
- 복도와 계단 (Hallway)
- 거실 (LivingRoom)
- 주방 및 식당 (Kitchen)
- 동생의 놀이방 (SiblingsRoom)
- 지하실 (Basement)
- 뒷마당과 정원 (Backyard)

### 작업 단계

#### 1.1 씬 생성 및 기본 설정

**수동 작업** (Unity 에디터):

1. **씬 생성**
   - `File` → `New Scene` → `Basic (Built-in)`
   - 씬 이름 저장: `Assets/Scenes/Ryu/[씬이름].unity`
   - 씬 이름은 `GameLocation` enum과 일치해야 함:
     - `PlayersRoom.unity`
     - `Hallway.unity`
     - `LivingRoom.unity`
     - `Kitchen.unity`
     - `SiblingsRoom.unity`
     - `Basement.unity`
     - `Backyard.unity`

2. **기본 정리**
   - 기본 `Main Camera` 삭제 (Prefab에 포함)
   - 기본 `Directional Light` 삭제 (필요시 추가)

#### 1.2 Prefab 배치

**수동 작업** (Unity 에디터):

`마크다운/개발/방_씬_생성_가이드.md`의 [Prefab 배치 순서](#prefab-배치-순서) 섹션을 참조하여 다음 순서로 배치:

1. `GameStateManager.prefab`
2. `MainCameraWithEventSystem.prefab`
3. `GameCanvas.prefab`
4. `GameManager.prefab`
5. `ApiClient.prefab`

**참조 연결 확인**:
- `GameManager` → `InputHandler`의 모든 참조 연결
- `GameManager` → `RoomTurnManager`의 모든 참조 연결
- `GameManager` → `SceneFadeManager`의 FadeImage 연결

#### 1.3 배경 이미지 설정

**수동 작업** (Unity 에디터):

1. **배경 이미지 준비**
   - `Assets/Assets/Background/` 폴더에 배경 이미지 저장
   - Import Settings:
     - `Texture Type`: Sprite (2D and UI)
     - `Sprite Mode`: Single
     - `Pixels Per Unit`: 100

2. **Background GameObject 생성**
   - Hierarchy에서 `Create Empty` → 이름: `Background`
   - `Add Component` → `Sprite Renderer`
   - 배경 이미지를 Sprite 필드에 드래그
   - Transform: Position (0, 0, 0)

#### 1.4 NPC 배치

**수동 작업** (Unity 에디터):

각 방에 필요한 NPC를 배치합니다. 시나리오에 따라:

- **주인공의 방**: NPC 없음 (시작 씬)
- **복도**: 이동 중 NPC들이 나타날 수 있음
- **거실**: 새아빠가 상주
- **주방**: 새엄마가 상주
- **동생의 놀이방**: 동생이 상주
- **지하실**: 할머니가 상주
- **뒷마당**: 강아지가 상주

**배치 방법**:
1. `Assets/Assets/Prefabs/NPCs/NPC_[이름].prefab` 드래그 앤 드롭
2. Transform 위치 조정
3. SpriteRenderer의 Sprite 설정
4. `ClickableObject`의 `Block Name` 확인 (기본값: GameObject 이름)

**참고**: NPC는 씬별로 배치하되, 실제 표시/숨김은 [NPC 상태 동기화 시스템](#2-npc-상태-동기화-시스템-구현)에서 처리됩니다.

#### 1.5 아이템 배치

**수동 작업** (Unity 에디터):

각 방에 필요한 아이템을 배치합니다. 시나리오에 따라:

- **주방**: 수면제 (찬장), 홍차 (식탁)
- **동생의 놀이방**: 동생의 장난감
- **지하실**: 기름병, 라이터
- **뒷마당**: 진짜 가족 사진 (강아지가 파묻어 둠)
- **기타**: 각 방의 특수 아이템

**배치 방법**:
1. `Assets/Assets/Prefabs/Items/Item_[이름].prefab` 드래그 앤 드롭
2. Transform 위치 조정
3. SpriteRenderer의 Sprite 설정
4. `ClickableObject`의 `Block Name` 확인

**참고**: 아이템은 씬별로 배치하되, 실제 표시/숨김은 [아이템 상태 동기화 시스템](#3-아이템-상태-동기화-시스템-구현)에서 처리됩니다.

#### 1.6 상호작용 오브젝트 배치

**수동 작업** (Unity 에디터):

각 방의 특수 상호작용 오브젝트를 배치합니다:

- **주인공의 방**: 개구멍 (탈출 통로)
- **거실**: 벽난로, 라디오/TV
- **주방**: 찬장, 식탁
- **동생의 놀이방**: 인형의 집 모형, 벽장
- **지하실**: 수술대, 할머니의 침대
- **뒷마당**: 개집

**배치 방법**:
1. `Assets/Assets/Prefabs/Interactables/InteractableObject.prefab` 드래그 앤 드롭
2. 이름을 적절하게 변경 (예: "Fireplace", "Cabinet")
3. Transform 위치 조정
4. SpriteRenderer의 Sprite 설정
5. BoxCollider2D 크기 조정

#### 1.7 Build Settings 설정

**수동 작업** (Unity 에디터):

1. `File` → `Build Settings` 열기
2. 각 씬을 `Add Open Scenes`로 추가
3. 씬 순서 확인:
   - 첫 번째: 시작 씬 (Tutorial 또는 PlayersRoom)
   - 마지막: GameOver

### 예상 작업 시간

- 씬당 약 30분~1시간 (배경 이미지 준비 포함)
- 총 7개 씬: 약 3.5~7시간

### 자동화 가능 여부

- ❌ **자동화 불가**: Unity 에디터에서 수동으로 Prefab을 배치하고 참조를 연결해야 함
- ✅ **템플릿 활용**: Tutorial 씬을 복제하여 시작점으로 사용 가능

---

## 2. NPC 상태 동기화 시스템 구현

### 작업 유형: **부분 자동화 가능** (스크립트 작성 필요)

### 개요

씬 로드 시 `GameStateManager`의 NPC 위치 정보를 기반으로 씬 내 NPC GameObject를 표시/숨김 처리하는 시스템입니다.

### 현재 상태

- ✅ `GameStateManager`에 NPC 위치 관리 기능 존재:
  - `SetNPCLocation(NPCType npc, GameLocation location)`
  - `GetNPCLocation(NPCType npc)`
- ❌ 씬 로드 시 NPC 표시/숨김 처리 시스템 없음

### 구현 필요 사항

#### 2.1 NPCController 스크립트 생성

**자동화 가능** (스크립트 작성):

새 스크립트: `Assets/Scripts/Ryu/Global/NPCs/NPCController.cs`

**기능**:
- 씬 로드 시 `GameStateManager`에서 NPC 위치 확인
- 현재 씬과 NPC 위치가 일치하면 표시, 아니면 숨김
- NPC 상태 변경 이벤트 구독
- NPC 호감도/인간성에 따른 시각적 피드백 (선택사항)

**구현 예시**:
```csharp
using UnityEngine;

/// <summary>
/// 씬 내 NPC GameObject를 GameStateManager의 상태와 동기화합니다.
/// </summary>
public class NPCController : MonoBehaviour
{
    [Header("NPC Settings")]
    [SerializeField] private NPCType npcType;
    [SerializeField] private GameLocation expectedLocation; // 이 NPC가 표시되어야 하는 씬
    
    private GameStateManager gameStateManager;
    private SpriteRenderer spriteRenderer;
    
    private void Start()
    {
        gameStateManager = GameStateManager.Instance;
        spriteRenderer = GetComponent<SpriteRenderer>();
        
        if (gameStateManager == null)
        {
            Debug.LogError($"[NPCController] GameStateManager를 찾을 수 없습니다: {gameObject.name}");
            return;
        }
        
        // 씬 로드 시 NPC 표시/숨김 처리
        SyncNPCVisibility();
        
        // NPC 상태 변경 이벤트 구독
        gameStateManager.OnNPCStatusChanged += OnNPCStatusChanged;
    }
    
    private void OnDestroy()
    {
        if (gameStateManager != null)
        {
            gameStateManager.OnNPCStatusChanged -= OnNPCStatusChanged;
        }
    }
    
    /// <summary>
    /// GameStateManager의 NPC 위치 정보를 기반으로 표시/숨김을 동기화합니다.
    /// </summary>
    private void SyncNPCVisibility()
    {
        if (gameStateManager == null) return;
        
        GameLocation currentLocation = gameStateManager.GetNPCLocation(npcType);
        GameLocation currentScene = GetCurrentSceneLocation();
        
        // NPC 위치와 현재 씬이 일치하면 표시
        bool shouldBeVisible = (currentLocation == currentScene) && 
                                 (currentLocation == expectedLocation);
        
        gameObject.SetActive(shouldBeVisible);
        
        Debug.Log($"[NPCController] {npcType} 동기화: 위치={currentLocation}, 씬={currentScene}, 표시={shouldBeVisible}");
    }
    
    /// <summary>
    /// 현재 씬의 GameLocation을 반환합니다.
    /// </summary>
    private GameLocation GetCurrentSceneLocation()
    {
        string sceneName = UnityEngine.SceneManagement.SceneManager.GetActiveScene().name;
        
        // 씬 이름을 GameLocation enum으로 변환
        if (System.Enum.TryParse<GameLocation>(sceneName, out GameLocation location))
        {
            return location;
        }
        
        Debug.LogWarning($"[NPCController] 씬 이름을 GameLocation으로 변환할 수 없습니다: {sceneName}");
        return GameLocation.Hallway; // 기본값
    }
    
    /// <summary>
    /// NPC 상태 변경 이벤트 핸들러
    /// </summary>
    private void OnNPCStatusChanged(NPCType npc, NPCStatus status)
    {
        if (npc != npcType) return;
        
        // NPC 위치가 변경되면 다시 동기화
        SyncNPCVisibility();
        
        // NPC 무력화 상태에 따른 처리 (선택사항)
        if (status.isDisabled)
        {
            // 무력화 시 시각적 피드백 (예: 반투명 처리)
            if (spriteRenderer != null)
            {
                Color color = spriteRenderer.color;
                color.a = 0.5f;
                spriteRenderer.color = color;
            }
        }
        else
        {
            // 정상 상태로 복원
            if (spriteRenderer != null)
            {
                Color color = spriteRenderer.color;
                color.a = 1f;
                spriteRenderer.color = color;
            }
        }
    }
}
```

#### 2.2 NPC Prefab에 NPCController 추가

**수동 작업** (Unity 에디터):

각 NPC Prefab에 `NPCController` 컴포넌트를 추가하고 설정:

1. `Assets/Assets/Prefabs/NPCs/NPC_NewMother.prefab` 열기
2. `Add Component` → `NPCController`
3. Inspector에서 설정:
   - `NPC Type`: NewMother
   - `Expected Location`: Kitchen (새엄마는 주방에 상주)
4. Prefab 저장

**각 NPC별 Expected Location**:
- `NPC_NewMother`: Kitchen
- `NPC_NewFather`: LivingRoom
- `NPC_Sibling`: SiblingsRoom
- `NPC_Dog`: Backyard
- `NPC_Grandmother`: Basement

#### 2.3 씬 로드 시 자동 동기화

**자동화됨** (스크립트에서 처리):

`NPCController`의 `Start()` 메서드에서 자동으로 동기화되므로 추가 작업 불필요.

#### 2.4 NPC 위치 변경 시 동기화

**자동화됨** (이벤트 시스템):

`GameStateManager.OnNPCStatusChanged` 이벤트를 통해 자동으로 동기화됩니다.

### 예상 작업 시간

- 스크립트 작성: 약 1~2시간
- Prefab 업데이트: 약 30분 (5개 NPC)

### 자동화 가능 여부

- ✅ **스크립트 작성**: 자동화 가능
- ⚠️ **Prefab 업데이트**: 수동 작업 필요 (Unity 에디터)

---

## 3. 아이템 상태 동기화 시스템 구현

### 작업 유형: **부분 자동화 가능** (스크립트 작성 필요)

### 개요

씬 로드 시 `GameStateManager`의 아이템 상태 정보를 기반으로 씬 내 아이템 GameObject를 표시/숨김 처리하는 시스템입니다.

### 현재 상태

- ✅ `GameStateManager`에 아이템 상태 관리 기능 존재:
  - `SetItemState(ItemType item, ItemState state, ItemLocation location)`
  - `GetItemState(ItemType item)`
  - `ItemStateManager`에 아이템 위치 정보 관리
- ❌ 씬 로드 시 아이템 표시/숨김 처리 시스템 없음

### 구현 필요 사항

#### 3.1 ItemController 스크립트 생성

**자동화 가능** (스크립트 작성):

새 스크립트: `Assets/Scripts/Ryu/Global/Items/ItemController.cs`

**기능**:
- 씬 로드 시 `GameStateManager`에서 아이템 상태 확인
- 아이템 상태가 `InWorld`이고 현재 씬에 위치하면 표시
- 아이템 상태가 `InInventory` 또는 `Used`이면 숨김
- 아이템 상태 변경 이벤트 구독

**구현 예시**:
```csharp
using UnityEngine;

/// <summary>
/// 씬 내 아이템 GameObject를 GameStateManager의 상태와 동기화합니다.
/// </summary>
public class ItemController : MonoBehaviour
{
    [Header("Item Settings")]
    [SerializeField] private ItemType itemType;
    [SerializeField] private GameLocation expectedLocation; // 이 아이템이 표시되어야 하는 씬
    
    private GameStateManager gameStateManager;
    private SpriteRenderer spriteRenderer;
    
    private void Start()
    {
        gameStateManager = GameStateManager.Instance;
        spriteRenderer = GetComponent<SpriteRenderer>();
        
        if (gameStateManager == null)
        {
            Debug.LogError($"[ItemController] GameStateManager를 찾을 수 없습니다: {gameObject.name}");
            return;
        }
        
        // 씬 로드 시 아이템 표시/숨김 처리
        SyncItemVisibility();
        
        // 아이템 상태 변경 이벤트 구독
        gameStateManager.OnItemStateChanged += OnItemStateChanged;
    }
    
    private void OnDestroy()
    {
        if (gameStateManager != null)
        {
            gameStateManager.OnItemStateChanged -= OnItemStateChanged;
        }
    }
    
    /// <summary>
    /// GameStateManager의 아이템 상태 정보를 기반으로 표시/숨김을 동기화합니다.
    /// </summary>
    private void SyncItemVisibility()
    {
        if (gameStateManager == null) return;
        
        ItemState currentState = gameStateManager.GetItemState(itemType);
        GameLocation currentScene = GetCurrentSceneLocation();
        
        // 아이템이 월드에 있고 현재 씬에 위치하면 표시
        bool shouldBeVisible = (currentState == ItemState.InWorld) && 
                               (currentScene == expectedLocation);
        
        gameObject.SetActive(shouldBeVisible);
        
        Debug.Log($"[ItemController] {itemType} 동기화: 상태={currentState}, 씬={currentScene}, 표시={shouldBeVisible}");
    }
    
    /// <summary>
    /// 현재 씬의 GameLocation을 반환합니다.
    /// </summary>
    private GameLocation GetCurrentSceneLocation()
    {
        string sceneName = UnityEngine.SceneManagement.SceneManager.GetActiveScene().name;
        
        // 씬 이름을 GameLocation enum으로 변환
        if (System.Enum.TryParse<GameLocation>(sceneName, out GameLocation location))
        {
            return location;
        }
        
        Debug.LogWarning($"[ItemController] 씬 이름을 GameLocation으로 변환할 수 없습니다: {sceneName}");
        return GameLocation.Hallway; // 기본값
    }
    
    /// <summary>
    /// 아이템 상태 변경 이벤트 핸들러
    /// </summary>
    private void OnItemStateChanged(ItemType item, WorldItemState itemState)
    {
        if (item != itemType) return;
        
        // 아이템 상태가 변경되면 다시 동기화
        SyncItemVisibility();
    }
    
    /// <summary>
    /// 아이템 클릭 시 인벤토리에 추가 (ClickableObject와 연동)
    /// </summary>
    public void OnItemClicked()
    {
        if (gameStateManager == null) return;
        
        // 아이템 획득 처리 (백엔드 API 호출 또는 로컬 처리)
        // 실제 구현은 게임 로직에 따라 다름
        Debug.Log($"[ItemController] {itemType} 클릭됨");
    }
}
```

#### 3.2 아이템 Prefab에 ItemController 추가

**수동 작업** (Unity 에디터):

각 아이템 Prefab에 `ItemController` 컴포넌트를 추가하고 설정:

1. `Assets/Assets/Prefabs/Items/Item_SleepingPill.prefab` 열기
2. `Add Component` → `ItemController`
3. Inspector에서 설정:
   - `Item Type`: SleepingPill
   - `Expected Location`: Kitchen (수면제는 주방 찬장에 있음)
4. Prefab 저장

**각 아이템별 Expected Location** (시나리오 참조):
- `Item_SleepingPill`: Kitchen
- `Item_EarlGreyTea`: Kitchen
- `Item_RealFamilyPhoto`: Backyard (강아지가 파묻어 둠)
- `Item_OilBottle`: Basement
- `Item_SilverLighter`: Basement
- `Item_SiblingsToy`: SiblingsRoom
- `Item_BrassKey`: Kitchen (새엄마가 보관) 또는 동적 위치

#### 3.3 아이템 획득 처리

**자동화 가능** (스크립트 작성):

아이템 클릭 시 인벤토리에 추가하는 로직:

1. `ClickableObject`와 연동하여 아이템 클릭 감지
2. 백엔드 API 호출 (또는 로컬 처리)
3. `GameStateManager.AddItem()` 호출
4. `ItemStateManager`가 자동으로 상태를 `InInventory`로 변경
5. `OnItemStateChanged` 이벤트가 발생하여 `ItemController`가 자동으로 숨김

#### 3.4 아이템 리스폰 처리

**자동화됨** (기존 시스템 활용):

`ItemStateManager.RespawnDailyItems()` 메서드가 이미 구현되어 있으므로, 날짜 변경 시 자동으로 리스폰됩니다.

### 예상 작업 시간

- 스크립트 작성: 약 1~2시간
- Prefab 업데이트: 약 1시간 (7개 아이템)

### 자동화 가능 여부

- ✅ **스크립트 작성**: 자동화 가능
- ⚠️ **Prefab 업데이트**: 수동 작업 필요 (Unity 에디터)

---

## 작업 우선순위 및 의존성

### 권장 작업 순서

1. **Phase 1: 새 방 씬 생성** (기반 작업)
   - 7개 방 씬 생성
   - Prefab 배치 및 참조 연결
   - 배경 이미지 설정
   - NPC 및 아이템 기본 배치

2. **Phase 2: NPC 상태 동기화 시스템** (기능 구현)
   - `NPCController` 스크립트 작성
   - NPC Prefab 업데이트
   - 테스트 및 검증

3. **Phase 3: 아이템 상태 동기화 시스템** (기능 구현)
   - `ItemController` 스크립트 작성
   - 아이템 Prefab 업데이트
   - 아이템 획득 처리 구현
   - 테스트 및 검증

### 의존성

- **NPC/아이템 동기화 시스템**은 **새 방 씬 생성**이 완료된 후 구현하는 것이 효율적입니다.
- 각 시스템은 독립적으로 구현 가능하지만, 통합 테스트를 위해 순차적으로 진행하는 것을 권장합니다.

---

## 자동화 가능 작업 요약

### 완전 자동화 가능
- ✅ NPCController 스크립트 작성
- ✅ ItemController 스크립트 작성
- ✅ 아이템 획득 처리 로직 구현

### 부분 자동화 가능
- ⚠️ NPC Prefab에 NPCController 추가 (스크립트는 자동, Prefab 수정은 수동)
- ⚠️ 아이템 Prefab에 ItemController 추가 (스크립트는 자동, Prefab 수정은 수동)

### 수동 작업 필요
- ❌ 새 방 씬 생성 (Unity 에디터에서 Prefab 배치)
- ❌ 배경 이미지 준비 및 설정
- ❌ NPC/아이템 위치 설정 (씬별로 다름)
- ❌ Build Settings 설정

---

## 다음 단계 실행 계획

### 옵션 1: 단계별 진행
1. 먼저 새 방 씬 생성 (수동 작업)
2. 그 다음 NPC/아이템 동기화 시스템 구현 (자동화 가능)

### 옵션 2: 병렬 진행
1. 새 방 씬 생성과 동시에 NPC/아이템 동기화 시스템 구현
2. 각 씬 생성 시 동기화 시스템 테스트

### 권장 사항
- **옵션 1 권장**: 기반 작업(씬 생성)을 먼저 완료한 후 기능 구현을 진행하는 것이 안정적입니다.

---

**작성일**: 2025-02-11  
**최종 수정일**: 2025-02-11

